/**
 * Coding Challenge Generator Bot
 * Generates coding challenges using OpenCode CLI (same pattern as other bots)
 * Saves challenges to database as the source of truth
 * 
 * IMPORTANT: Expected outputs are generated by RUNNING the actual solution code,
 * not by AI generation. This ensures test cases are always correct.
 * 
 * Usage:
 *   node script/coding-challenge-bot.js
 * 
 * Environment variables:
 *   INPUT_DIFFICULTY - 'easy', 'medium', or 'random' (default: random)
 *   INPUT_CATEGORY - specific category or 'random' (default: random)
 *   INPUT_COUNT - number of challenges to generate (default: 1)
 */

import { writeGitHubOutput, dbClient } from './utils.js';
import ai from './ai/index.js';
import { categories as CATEGORIES, difficulties as DIFFICULTIES, topCompanies as TOP_COMPANIES } from './ai/prompts/templates/coding-challenge.js';
import { spawn } from 'child_process';
import fs from 'fs';
import path from 'path';
import os from 'os';

/**
 * Execute Python code and return the result
 * This ensures expected outputs are generated from actual code execution, not AI
 */
async function executePythonCode(code, functionName, input) {
  return new Promise((resolve, reject) => {
    const wrappedCode = `
import json
from collections.abc import Iterator, Iterable

${code}

# Parse input and call function
_args = (${input},)
if len(_args) == 1 and isinstance(_args[0], tuple):
    _args = _args[0]

_result = ${functionName}(*_args)

# Convert to JSON-compatible format
def to_json(obj):
    if obj is None: return None
    if isinstance(obj, bool): return obj
    if isinstance(obj, (int, float, str)): return obj
    if isinstance(obj, (list, tuple)): return [to_json(x) for x in obj]
    if isinstance(obj, dict): return {str(k): to_json(v) for k, v in obj.items()}
    if isinstance(obj, Iterator): return [to_json(x) for x in obj]
    if isinstance(obj, Iterable) and not isinstance(obj, (str, bytes)): return [to_json(x) for x in obj]
    return str(obj)

print(json.dumps(to_json(_result)))
`;

    // Write to temp file
    const tempFile = path.join(os.tmpdir(), `challenge_test_${Date.now()}.py`);
    fs.writeFileSync(tempFile, wrappedCode);

    const python = spawn('python3', [tempFile], { timeout: 10000 });
    let stdout = '';
    let stderr = '';

    python.stdout.on('data', (data) => { stdout += data.toString(); });
    python.stderr.on('data', (data) => { stderr += data.toString(); });

    python.on('close', (code) => {
      // Clean up temp file
      try { fs.unlinkSync(tempFile); } catch (e) {}
      
      if (code === 0) {
        resolve(stdout.trim());
      } else {
        reject(new Error(`Python error: ${stderr || 'Unknown error'}`));
      }
    });

    python.on('error', (err) => {
      try { fs.unlinkSync(tempFile); } catch (e) {}
      reject(err);
    });
  });
}

/**
 * Extract function name from Python code
 */
function extractPythonFunctionName(code) {
  const match = code.match(/def\s+(\w+)\s*\(/);
  return match ? match[1] : null;
}

/**
 * Generate expected outputs by running the actual solution code
 * This is the key function that ensures test cases are correct
 */
async function generateExpectedOutputs(challenge) {
  const pythonSolution = challenge.sampleSolution?.python;
  if (!pythonSolution) {
    console.log('  ‚ö†Ô∏è No Python solution to execute');
    return challenge.testCases;
  }

  const functionName = extractPythonFunctionName(pythonSolution);
  if (!functionName) {
    console.log('  ‚ö†Ô∏è Could not extract function name from Python solution');
    return challenge.testCases;
  }

  console.log(`  üîß Generating expected outputs by running ${functionName}()...`);

  const updatedTestCases = [];
  for (const tc of challenge.testCases) {
    try {
      const actualOutput = await executePythonCode(pythonSolution, functionName, tc.input);
      
      // Compare with AI-generated expected output
      if (actualOutput !== tc.expectedOutput) {
        console.log(`    ‚ö†Ô∏è Test ${tc.id}: AI said "${tc.expectedOutput}", actual is "${actualOutput}" - FIXED`);
      }
      
      updatedTestCases.push({
        ...tc,
        expectedOutput: actualOutput // Use actual execution result
      });
    } catch (error) {
      console.log(`    ‚ùå Test ${tc.id} execution failed: ${error.message}`);
      // Keep AI-generated output as fallback, but flag it
      updatedTestCases.push({
        ...tc,
        _executionFailed: true
      });
    }
  }

  return updatedTestCases;
}

// Get 2-4 random companies
function getRandomCompanies() {
  const count = Math.floor(Math.random() * 3) + 2; // 2-4 companies
  const shuffled = [...TOP_COMPANIES].sort(() => Math.random() - 0.5);
  return shuffled.slice(0, count);
}

// Initialize coding_challenges table
async function initCodingChallengesTable() {
  console.log('üì¶ Ensuring coding_challenges table exists...');
  
  await dbClient.execute(`
    CREATE TABLE IF NOT EXISTS coding_challenges (
      id TEXT PRIMARY KEY,
      title TEXT NOT NULL,
      description TEXT NOT NULL,
      difficulty TEXT NOT NULL,
      category TEXT NOT NULL,
      tags TEXT,
      companies TEXT,
      starter_code_js TEXT,
      starter_code_py TEXT,
      test_cases TEXT NOT NULL,
      hints TEXT,
      solution_js TEXT,
      solution_py TEXT,
      complexity_time TEXT,
      complexity_space TEXT,
      complexity_explanation TEXT,
      time_limit INTEGER DEFAULT 15,
      created_at TEXT,
      last_updated TEXT
    )
  `);
  
  // Create indexes
  await dbClient.execute(`CREATE INDEX IF NOT EXISTS idx_coding_difficulty ON coding_challenges(difficulty)`);
  await dbClient.execute(`CREATE INDEX IF NOT EXISTS idx_coding_category ON coding_challenges(category)`);
  
  console.log('‚úÖ Table ready');
}

// Generate unique ID for coding challenge
async function generateChallengeId() {
  const result = await dbClient.execute(`
    SELECT MAX(CAST(SUBSTR(id, 3) AS INTEGER)) as max_num 
    FROM coding_challenges 
    WHERE id LIKE 'cc%' AND id GLOB 'cc[0-9]*'
  `);
  
  const maxNum = result.rows[0]?.max_num || 0;
  return `cc${maxNum + 1}`;
}

// Check for duplicate challenge by title similarity (fuzzy match)
async function isDuplicateChallenge(title) {
  // Normalize title for comparison
  const normalizedTitle = title.toLowerCase().replace(/[^a-z0-9]/g, '');
  
  const result = await dbClient.execute('SELECT title FROM coding_challenges');
  
  for (const row of result.rows) {
    const existingNormalized = row.title.toLowerCase().replace(/[^a-z0-9]/g, '');
    
    // Exact match after normalization
    if (existingNormalized === normalizedTitle) {
      return true;
    }
    
    // Check if one contains the other (catches "Two Sum" vs "Two Sum II")
    if (existingNormalized.includes(normalizedTitle) || normalizedTitle.includes(existingNormalized)) {
      // Only flag if they're very similar (>80% overlap)
      const shorter = Math.min(existingNormalized.length, normalizedTitle.length);
      const longer = Math.max(existingNormalized.length, normalizedTitle.length);
      if (shorter / longer > 0.8) {
        return true;
      }
    }
  }
  
  return false;
}

// Get existing challenge titles for a category (for prompt context)
async function getExistingTitlesForCategory(category) {
  const result = await dbClient.execute({
    sql: 'SELECT title FROM coding_challenges WHERE category = ? LIMIT 20',
    args: [category]
  });
  return result.rows.map(r => r.title);
}

// Validate challenge structure
function validateChallenge(data) {
  if (!data) return false;
  
  const required = ['title', 'description', 'difficulty', 'starterCode', 'testCases', 'sampleSolution', 'complexity'];
  for (const field of required) {
    if (!data[field]) {
      console.log(`‚ùå Missing required field: ${field}`);
      return false;
    }
  }
  
  if (!data.starterCode.javascript || !data.starterCode.python) {
    console.log('‚ùå Missing starter code for JS or Python');
    return false;
  }
  
  if (!data.sampleSolution.javascript || !data.sampleSolution.python) {
    console.log('‚ùå Missing sample solution for JS or Python');
    return false;
  }
  
  if (!Array.isArray(data.testCases) || data.testCases.length < 2) {
    console.log('‚ùå Need at least 2 test cases');
    return false;
  }
  
  // Validate test cases have required fields
  for (const tc of data.testCases) {
    if (!tc.input || tc.expectedOutput === undefined) {
      console.log('‚ùå Test case missing input or expectedOutput');
      return false;
    }
  }
  
  return true;
}

// Save challenge to database
async function saveChallengeToDb(challenge) {
  const id = await generateChallengeId();
  const now = new Date().toISOString();
  
  await dbClient.execute({
    sql: `INSERT INTO coding_challenges 
          (id, title, description, difficulty, category, tags, companies,
           starter_code_js, starter_code_py, test_cases, hints,
           solution_js, solution_py, complexity_time, complexity_space,
           complexity_explanation, time_limit, created_at, last_updated)
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
    args: [
      id,
      challenge.title,
      challenge.description,
      challenge.difficulty,
      challenge.category,
      JSON.stringify(challenge.tags || []),
      JSON.stringify(challenge.companies || []),
      challenge.starterCode?.javascript || '',
      challenge.starterCode?.python || '',
      JSON.stringify(challenge.testCases),
      JSON.stringify(challenge.hints || []),
      challenge.sampleSolution?.javascript || '',
      challenge.sampleSolution?.python || '',
      challenge.complexity?.time || 'O(n)',
      challenge.complexity?.space || 'O(1)',
      challenge.complexity?.explanation || '',
      challenge.timeLimit || 15,
      now,
      now
    ]
  });
  
  return id;
}

// Get count of challenges in database
async function getChallengeCount() {
  const result = await dbClient.execute('SELECT COUNT(*) as count FROM coding_challenges');
  return result.rows[0]?.count || 0;
}

async function generateChallenge(difficulty, category) {
  const companies = getRandomCompanies();
  const categoryTitles = await getExistingTitlesForCategory(category);
  
  console.log(`\nüéØ Generating ${difficulty} challenge for ${category}...`);
  console.log(`üè¢ Target companies: ${companies.join(', ')}`);
  
  console.log('\nüìù Using AI framework for generation');
  console.log('‚îÄ'.repeat(50));
  
  try {
    const data = await ai.run('coding-challenge', {
      difficulty,
      category,
      companies,
      existingTitles: categoryTitles
    });
    
    if (!validateChallenge(data)) {
      console.log('‚ùå Invalid challenge format');
      return null;
    }
    
    // Ensure test case IDs
    data.testCases = data.testCases.map((tc, i) => ({
      ...tc,
      id: tc.id || String(i + 1),
    }));
    
    // CRITICAL: Generate expected outputs by RUNNING the actual solution code
    // This ensures test cases are always correct, not relying on AI-generated outputs
    console.log('\nüß™ Validating test cases by executing solution...');
    data.testCases = await generateExpectedOutputs(data);
    
    // Check if any test case execution failed
    const failedTests = data.testCases.filter(tc => tc._executionFailed);
    if (failedTests.length > 0) {
      console.log(`‚ö†Ô∏è ${failedTests.length} test case(s) could not be validated`);
      // Remove the flag before saving
      data.testCases = data.testCases.map(tc => {
        const { _executionFailed, ...rest } = tc;
        return rest;
      });
    }
    
    // Ensure tags array
    if (!Array.isArray(data.tags)) {
      data.tags = [category];
    }
    
    // Ensure hints array
    if (!Array.isArray(data.hints)) {
      data.hints = ['Think about the problem step by step'];
    }
    
    // Ensure companies array
    if (!Array.isArray(data.companies)) {
      data.companies = companies;
    }
    
    return data;
  } catch (error) {
    console.log(`‚ùå AI error: ${error.message}`);
    return null;
  }
}

async function main() {
  console.log('=== ü§ñ Coding Challenge Generator Bot ===\n');
  
  // Initialize database table
  await initCodingChallengesTable();
  
  const initialCount = await getChallengeCount();
  console.log(`üìä Current challenges in database: ${initialCount}`);
  
  const inputDifficulty = process.env.INPUT_DIFFICULTY || 'random';
  const inputCategory = process.env.INPUT_CATEGORY || 'random';
  const inputCount = parseInt(process.env.INPUT_COUNT || '1', 10);
  
  console.log(`\nConfiguration:`);
  console.log(`  Difficulty: ${inputDifficulty}`);
  console.log(`  Category: ${inputCategory}`);
  console.log(`  Count: ${inputCount}`);
  
  const generated = [];
  const failed = [];
  
  for (let i = 0; i < inputCount; i++) {
    console.log(`\n--- Challenge ${i + 1}/${inputCount} ---`);
    
    const difficulty = inputDifficulty === 'random'
      ? DIFFICULTIES[Math.floor(Math.random() * DIFFICULTIES.length)]
      : inputDifficulty;
    
    const category = inputCategory === 'random'
      ? CATEGORIES[Math.floor(Math.random() * CATEGORIES.length)]
      : inputCategory;
    
    const challenge = await generateChallenge(difficulty, category);
    
    if (challenge) {
      // Check for duplicates
      if (await isDuplicateChallenge(challenge.title)) {
        console.log(`‚ö†Ô∏è Duplicate title detected: ${challenge.title}`);
        failed.push({ difficulty, category, reason: 'Duplicate title' });
        continue;
      }
      
      // Save to database
      try {
        const challengeId = await saveChallengeToDb(challenge);
        challenge.id = challengeId;
        generated.push(challenge);
        
        console.log(`‚úÖ Saved to database: ${challengeId}`);
        console.log(`   Title: ${challenge.title}`);
        console.log(`   Difficulty: ${challenge.difficulty}`);
        console.log(`   Category: ${challenge.category}`);
        console.log(`   Companies: ${challenge.companies?.join(', ') || 'N/A'}`);
        console.log(`   Test cases: ${challenge.testCases.length}`);
        
        // Note: Skip logBotActivity for coding challenges since they're not in questions table
        // The work_queue has a foreign key constraint on question_id
      } catch (dbError) {
        console.log(`‚ùå Database error: ${dbError.message}`);
        failed.push({ difficulty, category, reason: `DB error: ${dbError.message}` });
      }
    } else {
      failed.push({ difficulty, category, reason: 'Generation failed' });
    }
  }
  
  const finalCount = await getChallengeCount();
  
  // Summary
  console.log('\n=== SUMMARY ===');
  console.log(`Generated: ${generated.length}/${inputCount}`);
  console.log(`Failed: ${failed.length}`);
  console.log(`Total challenges in database: ${finalCount}`);
  
  if (generated.length > 0) {
    console.log('\n‚úÖ Added Challenges:');
    generated.forEach((c, i) => {
      console.log(`  ${i + 1}. [${c.id}] ${c.title} (${c.difficulty}, ${c.category})`);
    });
  }
  
  if (failed.length > 0) {
    console.log('\n‚ùå Failed:');
    failed.forEach(f => console.log(`  - ${f.category} (${f.difficulty}): ${f.reason}`));
  }
  
  writeGitHubOutput({
    generated_count: generated.length,
    failed_count: failed.length,
    total_challenges: finalCount,
    added_ids: generated.map(c => c.id).join(',')
  });
}

main().catch(e => {
  console.error('Fatal error:', e);
  process.exit(1);
});
