[
  {
    "id": "sd-1",
    "question": "Can you explain the Load Balancer strategy? When would you use Layer 4 vs Layer 7 load balancing?",
    "answer": "Load Balancing distributes traffic across multiple servers to ensure reliability and scalability.",
    "explanation": "A Load Balancer (LB) acts as a reverse proxy. \n\n**Layer 4 (Transport Layer)**: Distributes based on IP/Port. Fast, low overhead, but no context of content. Good for simple packet distribution.\n\n**Layer 7 (Application Layer)**: Inspects HTTP headers/content. Can route based on URL/cookies (e.g., /api to Service A, /static to Service B). More expensive but smarter.\n\n**Common Algorithms**:\n- **Round Robin**: Sequential.\n- **Least Connections**: Sends to server with fewest active connections.\n- **IP Hash**: Ensures a user always goes to the same server (sticky sessions).",
    "tags": [
      "infra",
      "scale",
      "networking"
    ],
    "difficulty": "advanced",
    "channel": "system-design",
    "subChannel": "infrastructure",
    "diagram": "graph LR\n    User --> LB[Load Balancer]\n    LB -->|Layer 4| S1[\"Server 1<br/>IP:Port\"]\n    LB -->|Layer 7| S2[\"Server 2<br/>/api\"]\n    style LB fill:#fff,stroke:#000,color:#000"
  },
  {
    "id": "sd-2",
    "question": "What is Consistent Hashing and why is it critical for distributed caches?",
    "answer": "Consistent Hashing maps keys to a ring of nodes to minimize data movement when scaling.",
    "explanation": "In standard `hash(key) % N`, adding a node changes `N`, causing nearly ALL keys to remap (cache stampede).\n\n**Consistent Hashing** maps both servers and keys to a circle (0-360°). Keys map to the next server clockwise.\n\n**Benefit**: Adding/removing a node only affects the immediate neighbors (k/N keys move), not the whole cluster.\n\nUsed in: DynamoDB, Cassandra, Discord Ringpop.",
    "tags": [
      "hashing",
      "dist-sys",
      "caching"
    ],
    "difficulty": "advanced",
    "channel": "system-design",
    "subChannel": "distributed-systems",
    "diagram": "\ngraph TD\n    subgraph Hash Ring\n    N1((Node 1)) --- N2((Node 2))\n    N2 --- N3((Node 3))\n    N3 --- N1\n    end\n    Key[Key K] -.->|Clockwise| N2\n    style N2 fill:#f00,stroke:#fff,color:#fff\n"
  },
  {
    "id": "sd-3",
    "question": "Explain the CAP Theorem. Can you really 'choose two'?",
    "answer": "CAP states a distributed store can only provide 2 of 3: Consistency, Availability, Partition Tolerance.",
    "explanation": "**Partition Tolerance (P)** is NOT optional in distributed systems (networks fail). \n\nSo the real choice is **CP vs AP** during a partition:\n\n- **CP (Consistency)**: Return error/timeout if data can't be synced. (e.g., Banking - better to fail than show wrong balance).\n- **AP (Availability)**: Return stale data but keep running. (e.g., Facebook Feed - better to show old posts than nothing).\n\n**PACELC Theorem** extends this: Else (when no partition), choose Latency (L) vs Consistency (C).",
    "tags": [
      "theory",
      "dist-sys",
      "database"
    ],
    "difficulty": "advanced",
    "channel": "system-design",
    "subChannel": "distributed-systems",
    "diagram": "graph TD\n    CAP[CAP Theorem]\n    CAP --> C[Consistency]\n    CAP --> A[Availability]\n    CAP --> P[Partition Tolerance]\n    Note[Pick 2 of 3]\n    style Note fill:#f59e0b,stroke:#fff,color:#000"
  },
  {
    "id": "sd-4",
    "question": "How do you handle Database Sharding? What are the downsides?",
    "answer": "Sharding splits a large database into smaller, faster, easily managed parts called data shards.",
    "explanation": "**Horizontal Partitioning**: Splitting rows based on a Shard Key (e.g., UserID).\n\n**Downsides/Challenges**:\n1. **Resharding**: Hard to move data when a shard fills up.\n2. **Hotspot Key**: If Justin Bieber is on Shard 1, Shard 1 melts down.\n3. **Joins**: Cross-shard joins are expensive/impossible.\n\n**Mitigation**: Consistent Hashing, Virtual Nodes.",
    "tags": [
      "db",
      "scale",
      "architecture"
    ],
    "difficulty": "advanced",
    "channel": "system-design",
    "subChannel": "database",
    "diagram": "\ngraph TD\n    App --> Router\n    Router -->|ID < 100| S1[(Shard 1)]\n    Router -->|ID > 100| S2[(Shard 2)]\n"
  },
  {
    "id": "sd-5",
    "question": "Design a Rate Limiter. What algorithms would you consider?",
    "answer": "Rate Limiting controls the amount of traffic sent or received by a network interface controller.",
    "explanation": "Prevents DoS attacks and resource starvation.\n\n**Algorithms**:\n1. **Token Bucket**: Tokens added at rate `r`. Request consumes token. Allows bursts.\n2. **Leaky Bucket**: Requests enter queue, processed at constant rate. Smooths traffic.\n3. **Fixed Window**: Count requests in 1s window. Edge case: 2x traffic at window boundary.\n4. **Sliding Window Log**: Precise but expensive (stores timestamps).\n\n**Implementation**: Redis (Lua scripts for atomicity).",
    "tags": [
      "security",
      "api",
      "algorithms"
    ],
    "difficulty": "advanced",
    "channel": "system-design",
    "subChannel": "api-design",
    "diagram": "\ngraph LR\n    Req[Request] --> Check{Buckets Full?}\n    Check -->|No| Process[Process]\n    Check -->|Yes| Drop[429 Too Many Requests]\n"
  },
  {
    "id": "al-1",
    "question": "When would you use a Linked List over an Array?",
    "answer": "Linked Lists excel at insertions/deletions, Arrays excel at random access.",
    "explanation": "**Array**:\n- Access: O(1) (Direct memory address)\n- Insert/Delete: O(n) (Shift elements)\n- Memory: Contiguous\n\n**Linked List**:\n- Access: O(n) (Traversal)\n- Insert/Delete: O(1) (Change pointer - if you have the node)\n- Memory: Scattered (Heap)\n\n**Use List when**: Implementing Queues, Stacks, or when memory is fragmented.",
    "tags": [
      "struct",
      "comparison",
      "basics"
    ],
    "difficulty": "beginner",
    "channel": "algorithms",
    "subChannel": "data-structures",
    "diagram": "\ngraph LR\n    subgraph Array\n    A1[0] --- A2[1] --- A3[2] --- A4[3]\n    end\n    subgraph LinkedList\n    L1[Node] --> L2[Node] --> L3[Node]\n    end\n"
  },
  {
    "id": "al-2",
    "question": "Explain QuickSort vs MergeSort. Which is better?",
    "answer": "QuickSort is generally faster in practice (cache locality) but unstable. MergeSort is stable but uses O(n) space.",
    "explanation": "**QuickSort**:\n- Avg: O(n log n), Worst: O(n^2) (bad pivot).\n- Space: O(log n) stack.\n- **In-place**.\n\n**MergeSort**:\n- Always O(n log n).\n- Space: O(n) (aux array).\n- **Stable** (preserves order of equals).\n\n**Verdict**: Arrays -> QuickSort. Linked Lists -> MergeSort.",
    "tags": [
      "sort",
      "recursion",
      "complexity"
    ],
    "difficulty": "intermediate",
    "channel": "algorithms",
    "subChannel": "sorting",
    "diagram": "\ngraph TD\n    A[Array] --> P{Pick Pivot}\n    P --> L[Left < Pivot]\n    P --> R[Right > Pivot]\n    L --> Sort1[Recurse]\n    R --> Sort2[Recurse]\n"
  },
  {
    "id": "al-3",
    "question": "What is Dynamic Programming? How is it different from Recursion?",
    "answer": "DP is Recursion + Optimization (Memoization/Tabulation).",
    "explanation": "Recursion solves subproblems blindly (potentially repeating work).\n\n**DP** stores the result of subproblems so you never solve the same problem twice.\n\n**Example**: Fibonacci.\n- Recursion: `fib(n-1) + fib(n-2)` -> O(2^n)\n- DP: Store `fib` array -> O(n)\n\n**Two Approaches**:\n1. Top-Down (Memoization)\n2. Bottom-Up (Tabulation)",
    "tags": [
      "dp",
      "optimization",
      "theory"
    ],
    "difficulty": "advanced",
    "channel": "algorithms",
    "subChannel": "dynamic-programming",
    "diagram": "\ngraph TD\n    P[Problem] --> S1[Subproblem 1]\n    P --> S2[Subproblem 2]\n    S1 --> C[(Cache)]\n    S2 --> C\n    C --> R[Result]\n"
  },
  {
    "id": "fe-1",
    "question": "Explain the React Virtual DOM and Reconciliation process.",
    "answer": "Virtual DOM is a lightweight copy of the real DOM. Reconciliation is the sync process.",
    "explanation": "1. **Render**: React creates a Virtual DOM tree from components.\n2. **Diff**: When state changes, create a new VDOM tree and compare with the old one (Diffing Algorithm).\n3. **Patch**: Calculate the minimum number of changes needed and update the **Real DOM** in a batch.\n\n**Keys** help React identify which items have changed, added, or removed in lists, preventing unnecessary re-renders.",
    "tags": [
      "react",
      "perf",
      "internals"
    ],
    "difficulty": "intermediate",
    "channel": "frontend",
    "subChannel": "react",
    "diagram": "\nflowchart LR\n    State --> VDOM_New\n    VDOM_Old --> Diff\n    VDOM_New --> Diff{Diffing}\n    Diff --> Patch[Update Real DOM]\n"
  },
  {
    "id": "fe-2",
    "question": "What is the Event Loop in JavaScript? How do Microtasks differ from Macrotasks?",
    "answer": "The Event Loop coordinates the Call Stack, Web APIs, and Callback Queues.",
    "explanation": "JS is single-threaded.\n\n1. **Call Stack**: Executes sync code.\n2. **Microtask Queue**: Promises, MutationObservers. (Higher Priority - processed immediately after stack clears).\n3. **Macrotask Queue**: setTimeout, setInterval, I/O. (Processed one per loop tick).\n\n**Order**: Sync -> All Microtasks -> Render UI -> One Macrotask -> Repeat.",
    "tags": [
      "js",
      "async",
      "core"
    ],
    "difficulty": "beginner",
    "channel": "frontend",
    "subChannel": "javascript",
    "diagram": "\ngraph TD\n    Stack[Call Stack] -->|Empty?| CheckMicro{Microtasks?}\n    CheckMicro -->|Yes| RunMicro[Run All Microtasks]\n    RunMicro --> CheckMicro\n    CheckMicro -->|No| Render[Render UI]\n    Render --> RunMacro[Run One Macrotask]\n    RunMacro --> Stack\n"
  },
  {
    "id": "fe-3",
    "question": "Explain 'Closure' in JavaScript with a practical use case.",
    "answer": "A Closure is a function remembering its lexical scope even when executed outside that scope.",
    "explanation": "**Concept**: When a function returns another function, the inner function retains access to the outer function's variables.\n\n**Use Case: Data Privacy / Currying**\n```javascript\nfunction createCounter() {\n  let count = 0; // Private variable\n  return {\n    increment: () => count++,\n    get: () => count\n  };\n}\nconst c = createCounter();\nc.increment(); // 1\n// count is not accessible directly\n```",
    "tags": [
      "js",
      "scope",
      "patterns"
    ],
    "difficulty": "intermediate",
    "channel": "frontend",
    "subChannel": "javascript",
    "diagram": "\ngraph TD\n    Outer[Outer Function] --> Var[count = 0]\n    Outer --> Inner[Inner Function]\n    Inner -.->|Remembers| Var\n"
  },
  {
    "id": "db-1",
    "question": "What is the difference between Clustered and Non-Clustered Indexes?",
    "answer": "Clustered Index defines the physical order of data. Non-Clustered is a separate lookup structure.",
    "explanation": "**Clustered Index**:\n- Only 1 per table (usually Primary Key).\n- Leaf nodes contain the ACTUAL data rows.\n- Faster for range queries.\n\n**Non-Clustered Index**:\n- Multiple allowed.\n- Leaf nodes contain pointers to the data (row ID or clustered key).\n- Requires 'Bookmark Lookup' (extra hop) to get full data.",
    "tags": [
      "sql",
      "indexing",
      "perf"
    ],
    "difficulty": "beginner",
    "channel": "database",
    "subChannel": "sql",
    "diagram": "graph TD\n    subgraph Clustered\n    Root1 --> Data[\"Data Pages<br/>Sorted\"]\n    end\n    subgraph NonClustered\n    Root2 --> Ptr[Pointers]\n    Ptr -.-> Data\n    end"
  },
  {
    "id": "db-2",
    "question": "Explain ACID properties in the context of a banking transaction.",
    "answer": "Atomicity, Consistency, Isolation, Durability guarantee valid transactions.",
    "explanation": "**Scenario**: A transfers $100 to B.\n\n- **Atomicity**: All or nothing. If debit A succeeds but credit B fails, ROLLBACK everything.\n- **Consistency**: DB moves from one valid state to another (constraints satisfied, total money same).\n- **Isolation**: Concurrent transactions don't interfere. If C checks A's balance during transfer, they see either pre- or post-state, not intermediate.\n- **Durability**: Once committed, it stays saved even if power fails (Write Ahead Log).",
    "tags": [
      "acid",
      "transactions",
      "theory"
    ],
    "difficulty": "intermediate",
    "channel": "database",
    "subChannel": "transactions",
    "diagram": "\ngraph TD\n    A[Atomicity] --> T[Transaction]\n    C[Consistency] --> T\n    I[Isolation] --> T\n    D[Durability] --> T\n    T --> DB[(Database)]\n"
  },
  {
    "id": "do-1",
    "question": "What is the difference between Docker and Kubernetes?",
    "answer": "Docker creates the container (Runtime/Format). Kubernetes orchestrates them (Management).",
    "explanation": "**Docker**: Like a shipping container. Packages app + libs + OS deps into a portable image.\n\n**Kubernetes (K8s)**: Like the shipping crane/port authority. Manages loading containers onto ships (nodes), replacing broken ones (healing), and routing traffic.\n\n*You can use Docker without K8s, but K8s needs a container runtime (like Docker/containerd).*",
    "tags": [
      "k8s",
      "docker",
      "concepts"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "kubernetes",
    "diagram": "\ngraph LR\n    Docker[Docker] --> C1[Container]\n    Docker --> C2[Container]\n    K8s[Kubernetes] --> N1[Node]\n    K8s --> N2[Node]\n    N1 --> C1\n    N2 --> C2\n"
  },
  {
    "id": "do-2",
    "question": "Explain Blue/Green vs Canary Deployments.",
    "answer": "Strategies to reduce deployment risk.",
    "explanation": "**Blue/Green**:\n- Two identical envs (Blue=Live, Green=Staging).\n- Deploy v2 to Green. Test.\n- Switch Router 100% to Green.\n- Fast rollback, but requires 2x resources.\n\n**Canary**:\n- Gradual rollout.\n- Route 5% traffic to v2. Monitor metrics.\n- Increment to 25%, 50%, 100%.\n- Lower risk, lower resource cost, but slower rollout.",
    "tags": [
      "deployment",
      "strategy",
      "cicd",
      "jenkins"
    ],
    "difficulty": "intermediate",
    "channel": "devops",
    "subChannel": "cicd",
    "diagram": "\ngraph LR\n    LB[Load Balancer] -->|100%| Blue[Blue v1]\n    LB -.->|Switch| Green[Green v2]\n    subgraph Canary\n    LB2[LB] -->|95%| V1[v1]\n    LB2 -->|5%| V2[v2]\n    end\n"
  },
  {
    "id": "do-3",
    "question": "What is Infrastructure as Code (IaC)? Why use Terraform?",
    "answer": "Managing infrastructure through code (git) rather than manual console clicks.",
    "explanation": "**Benefits**:\n- **Reproducibility**: Same env every time.\n- **Version Control**: Git history of infra changes.\n- **Automation**: One click deploy.\n\n**Terraform vs Ansible**:\n- Terraform: Provisioning (Building the server/VPC).\n- Ansible: Configuration (Installing software on the server).",
    "tags": [
      "infra",
      "automation",
      "terraform"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "terraform",
    "diagram": "\ngraph LR\n    Code[IaC Code] --> Git[Git Repo]\n    Git --> TF[Terraform]\n    TF --> Cloud[Cloud Infra]\n"
  },
  {
    "id": "sre-1",
    "question": "What are SLIs, SLOs, and SLAs? How do they relate?",
    "answer": "Metrics, Goals, and Consequences.",
    "explanation": "1. **SLI (Indicator)**: The actual number. \"My latency is 200ms\".\n2. **SLO (Objective)**: The internal goal. \"Latency should be < 300ms for 99% of requests\".\n3. **SLA (Agreement)**: The legal contract with users. \"If latency > 500ms, we refund you 10%\".\n\n*SREs focus on SLOs. SLAs are for lawyers.*",
    "tags": [
      "metrics",
      "policy",
      "definitions",
      "observability"
    ],
    "difficulty": "beginner",
    "channel": "sre",
    "subChannel": "observability",
    "diagram": "graph TD\n    SLI[\"Indicator<br/>Reality\"] -->|Measured Against| SLO[\"Objective<br/>Goal\"]\n    SLO -->|Buffer| SLA[\"Agreement<br/>Contract\"]"
  },
  {
    "id": "sre-2",
    "question": "What is an Error Budget and how do you use it?",
    "answer": "100% - SLO = Error Budget. It's the allowed amount of unreliability.",
    "explanation": "If SLO is 99.9% uptime, you have 0.1% error budget (approx 43 mins/month).\n\n**Usage**:\n- **Budget Remaining?**: Ship features fast, take risks, do chaos engineering.\n- **Budget Exhausted?**: FREEZE deployments. Focus 100% on reliability until budget recovers.\n\n*It aligns Dev (speed) and Ops (stability) incentives.*",
    "tags": [
      "management",
      "concept",
      "risk"
    ],
    "difficulty": "beginner",
    "channel": "sre",
    "subChannel": "reliability",
    "diagram": "\ngraph LR\n    SLO[99.9% SLO] --> EB[0.1% Error Budget]\n    EB -->|Remaining| Ship[Ship Features]\n    EB -->|Exhausted| Freeze[Freeze Deploys]\n"
  },
  {
    "id": "gh-1",
    "question": "What is DevOps?",
    "answer": "DevOps is a set of practices that combines software development (Dev) and IT operations (Ops). It aims to shorten the systems development life cycle a...",
    "explanation": "DevOps is a set of practices that combines software development (Dev) and IT operations (Ops). It aims to shorten the systems development life cycle and provide continuous delivery with high software quality. DevOps is complementary with Agile software development; several DevOps aspects came from Agile methodology.",
    "tags": [
      "basics"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "general",
    "diagram": "\ngraph LR\n    Dev[Development] --> CI[CI/CD]\n    CI --> Ops[Operations]\n    Ops --> Monitor[Monitor]\n    Monitor --> Dev\n"
  },
  {
    "id": "gh-2",
    "question": "What are the benefits of DevOps?",
    "answer": "The main benefits of DevOps include:",
    "explanation": "The main benefits of DevOps include:\n\n1. Faster delivery of features\n2. More stable operating environments\n3. Improved communication and collaboration\n4. More time to innovate (rather than fix/maintain)\n5. Reduced deployment failures and rollbacks\n6. Shorter mean time to recovery",
    "tags": [
      "basics"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "general",
    "diagram": "\ngraph TD\n    DevOps --> Speed[Faster Delivery]\n    DevOps --> Stable[Stability]\n    DevOps --> Collab[Collaboration]\n    DevOps --> MTTR[Lower MTTR]\n"
  },
  {
    "id": "gh-3",
    "question": "What is Continuous Integration?",
    "answer": "Continuous Integration (CI) is a development practice where developers integrate code into a shared repository frequently, preferably several times a ...",
    "explanation": "Continuous Integration (CI) is a development practice where developers integrate code into a shared repository frequently, preferably several times a day. Each integration can then be verified by an automated build and automated tests.\n\nKey aspects of CI include:\n- Maintaining a single source repository\n- Automating the build\n- Making the build self-testing\n- Everyone commits to the baseline every day\n- Every commit builds on an integration machine\n- Keep the build fast\n- Test in a clone of the production environment\n- Make it easy to get the latest deliverables\n- Everyone can see the results of the latest build\n- Automate deployment",
    "tags": [
      "basics"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "general",
    "diagram": "\ngraph LR\n    Code[Code] --> Commit[Commit]\n    Commit --> Build[Build]\n    Build --> Test[Test]\n    Test --> Merge[Merge]\n"
  },
  {
    "id": "gh-4",
    "question": "What is Docker?",
    "answer": "Docker is a platform for developing, shipping, and running applications in containers. Containers allow developers to package up an application with a...",
    "explanation": "Docker is a platform for developing, shipping, and running applications in containers. Containers allow developers to package up an application with all the parts it needs, such as libraries and other dependencies, and ship it all out as one package.",
    "tags": [
      "docker",
      "containers"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "containers",
    "diagram": "\ngraph TD\n    App[Application] --> Libs[Libraries]\n    Libs --> Deps[Dependencies]\n    Deps --> Container[Container]\n"
  },
  {
    "id": "gh-5",
    "question": "What is the difference between Docker Image and Docker Container?",
    "answer": "- Docker Image: A Docker image is a read-only template containing a set of instructions for creating a Docker container. It includes the application c...",
    "explanation": "- **Docker Image:** A Docker image is a read-only template containing a set of instructions for creating a Docker container. It includes the application code, runtime, libraries, dependencies, and system tools.\n\n- **Docker Container:** A container is a runnable instance of an image. You can create, start, stop, move, or delete a container using the Docker API or CLI. A container is isolated from other containers and the host machine.",
    "tags": [
      "docker",
      "containers"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "containers",
    "diagram": "\ngraph LR\n    Image[Image - Template] --> C1[Container 1]\n    Image --> C2[Container 2]\n    Image --> C3[Container 3]\n"
  },
  {
    "id": "gh-6",
    "question": "What is Dockerfile?",
    "answer": "A Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image. Using `docker build`, users...",
    "explanation": "A Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image. Using `docker build`, users can create an automated build that executes several command-line instructions in succession.\n\nExample of a simple Dockerfile:\n```dockerfile\nFROM node:14\nWORKDIR /app\nCOPY package*.json ./\nRUN npm install\nCOPY . .\nEXPOSE 3000\nCMD [\"npm\", \"start\"]\n```",
    "tags": [
      "docker",
      "containers"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "containers",
    "diagram": "\ngraph TD\n    FROM[FROM base] --> COPY[COPY files]\n    COPY --> RUN[RUN commands]\n    RUN --> CMD[CMD entrypoint]\n"
  },
  {
    "id": "gh-7",
    "question": "What is Kubernetes?",
    "answer": "Kubernetes (K8s) is an open-source container orchestration platform that automates the deployment, scaling, and management of containerized applicatio...",
    "explanation": "Kubernetes (K8s) is an open-source container orchestration platform that automates the deployment, scaling, and management of containerized applications. It was originally developed by Google and is now maintained by the Cloud Native Computing Foundation (CNCF).",
    "tags": [
      "k8s",
      "orchestration"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "kubernetes",
    "diagram": "\ngraph TD\n    K8s[Kubernetes] --> Deploy[Auto Deploy]\n    K8s --> Scale[Auto Scale]\n    K8s --> Heal[Self Heal]\n"
  },
  {
    "id": "gh-8",
    "question": "What are the main components of Kubernetes architecture?",
    "answer": "Kubernetes architecture consists of the following main components:",
    "explanation": "Kubernetes architecture consists of the following main components:\n\n1. **Master Node Components:**\n- API Server\n- etcd\n- Controller Manager\n- Scheduler\n\n2. **Worker Node Components:**\n- Kubelet\n- Container Runtime\n- Kube Proxy",
    "tags": [
      "k8s",
      "orchestration"
    ],
    "difficulty": "intermediate",
    "channel": "devops",
    "subChannel": "kubernetes",
    "diagram": "\ngraph TD\n    Master[Master Node] --> API[API Server]\n    Master --> etcd[(etcd)]\n    Worker[Worker Node] --> Kubelet\n    Worker --> Runtime[Container Runtime]\n"
  },
  {
    "id": "gh-9",
    "question": "What is a Pod in Kubernetes?",
    "answer": "A Pod is the smallest deployable unit in Kubernetes. It represents a single instance of a running process in your cluster. Pods can contain one or mor...",
    "explanation": "A Pod is the smallest deployable unit in Kubernetes. It represents a single instance of a running process in your cluster. Pods can contain one or more containers, storage resources, a unique network IP, and options that govern how the container(s) should run.\n\nExample of a simple Pod YAML:\n```yaml\napiVersion: v1\nkind: Pod\nmetadata:\nname: nginx-pod\nspec:\ncontainers:\n- name: nginx\nimage: nginx:1.14.2\nports:\n- containerPort: 80\n```",
    "tags": [
      "k8s",
      "orchestration"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "kubernetes",
    "diagram": "\ngraph LR\n    Pod[Pod] --> C1[Container 1]\n    Pod --> C2[Container 2]\n    Pod --> Vol[(Shared Volume)]\n"
  },
  {
    "id": "gh-10",
    "question": "What is CI/CD Pipeline?",
    "answer": "A CI/CD Pipeline is a series of steps that must be performed in order to deliver a new version of software. A pipeline typically includes stages for:",
    "explanation": "A CI/CD Pipeline is a series of steps that must be performed in order to deliver a new version of software. A pipeline typically includes stages for:\n\n1. Building the code\n2. Running automated tests\n3. Deploying to staging/production environments\n\nExample of a basic Jenkins Pipeline:\n```groovy\npipeline {\nagent any\nstages {\nstage('Build') {\nsteps {\nsh 'npm install'\nsh 'npm run build'\n}\n}\nstage('Test') {\nsteps {\nsh 'npm run test'\n}\n}\nstage('Deploy') {\nsteps {\nsh './deploy.sh'\n}\n}\n}\n}\n```",
    "tags": [
      "cicd",
      "automation"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "cicd",
    "diagram": "\ngraph LR\n    Build[Build] --> Test[Test]\n    Test --> Stage[Staging]\n    Stage --> Prod[Production]\n"
  },
  {
    "id": "gh-11",
    "question": "What is Jenkins?",
    "answer": "Jenkins is an open-source automation server that helps automate parts of software development related to building, testing, and deploying, facilitatin...",
    "explanation": "Jenkins is an open-source automation server that helps automate parts of software development related to building, testing, and deploying, facilitating continuous integration and continuous delivery (CI/CD).\n\nKey features include:\n- Easy installation and configuration\n- Hundreds of plugins available\n- Built-in GUI tool for easy updates\n- Supports distributed builds with master-slave architecture\n- Extensible with a huge number of plugins",
    "tags": [
      "cicd",
      "automation"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "cicd",
    "diagram": "\ngraph TD\n    Jenkins[Jenkins Master] --> A1[Agent 1]\n    Jenkins --> A2[Agent 2]\n    A1 --> Build[Build Jobs]\n    A2 --> Test[Test Jobs]\n"
  },
  {
    "id": "gh-12",
    "question": "What is Cloud Computing?",
    "answer": "Cloud computing is the delivery of computing services—including servers, storage, databases, networking, software, analytics, and intelligence—over th...",
    "explanation": "Cloud computing is the delivery of computing services—including servers, storage, databases, networking, software, analytics, and intelligence—over the Internet (\"the cloud\") to offer faster innovation, flexible resources, and economies of scale.",
    "tags": [
      "cloud",
      "aws",
      "azure",
      "gcp"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "aws",
    "diagram": "\ngraph TD\n    Cloud[Cloud] --> Compute[Compute]\n    Cloud --> Storage[(Storage)]\n    Cloud --> DB[(Database)]\n    Cloud --> Net[Network]\n"
  },
  {
    "id": "gh-13",
    "question": "What is AWS (Amazon Web Services)?",
    "answer": "AWS is a comprehensive and widely adopted cloud platform, offering over 200 fully featured services from data centers globally. Key services include:",
    "explanation": "AWS is a comprehensive and widely adopted cloud platform, offering over 200 fully featured services from data centers globally. Key services include:\n\n1. **Compute:**\n- EC2 (Elastic Compute Cloud)\n- Lambda (Serverless Computing)\n- ECS (Elastic Container Service)\n\n2. **Storage:**\n- S3 (Simple Storage Service)\n- EBS (Elastic Block Store)\n- EFS (Elastic File System)\n\n3. **Database:**\n- RDS (Relational Database Service)\n- DynamoDB (NoSQL Database)\n- Redshift (Data Warehouse)",
    "tags": [
      "cloud",
      "aws",
      "azure",
      "gcp"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "aws",
    "diagram": "\ngraph TD\n    AWS --> EC2[EC2 Compute]\n    AWS --> S3[(S3 Storage)]\n    AWS --> RDS[(RDS Database)]\n    AWS --> Lambda[Lambda]\n"
  },
  {
    "id": "gh-14",
    "question": "What is Azure?",
    "answer": "Azure is Microsoft's cloud computing platform that provides a wide variety of services including:",
    "explanation": "Azure is Microsoft's cloud computing platform that provides a wide variety of services including:\n\n1. **Compute Services:**\n- Virtual Machines\n- App Services\n- Azure Functions\n\n2. **Storage Services:**\n- Blob Storage\n- File Storage\n- Queue Storage\n\n3. **Network Services:**\n- Virtual Network\n- Load Balancer\n- Application Gateway",
    "tags": [
      "cloud",
      "aws",
      "azure",
      "gcp"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "aws",
    "diagram": "\ngraph TD\n    Azure --> VM[Virtual Machines]\n    Azure --> Blob[(Blob Storage)]\n    Azure --> Func[Functions]\n    Azure --> VNet[Virtual Network]\n"
  },
  {
    "id": "gh-15",
    "question": "What are the different types of cloud services?",
    "answer": "The main types of cloud services are:",
    "explanation": "The main types of cloud services are:\n\n1. **IaaS (Infrastructure as a Service):**\n- Provides virtualized computing resources\n- Examples: AWS EC2, Azure VMs\n\n2. **PaaS (Platform as a Service):**\n- Provides platform allowing customers to develop, run, and manage applications\n- Examples: Heroku, Google App Engine\n\n3. **SaaS (Software as a Service):**\n- Provides software applications over the internet\n- Examples: Salesforce, Google Workspace\n\n4. **FaaS (Function as a Service):**\n- Provides serverless computing capabilities\n- Examples: AWS Lambda, Azure Functions",
    "tags": [
      "cloud",
      "aws",
      "azure",
      "gcp"
    ],
    "difficulty": "intermediate",
    "channel": "devops",
    "subChannel": "aws",
    "diagram": "\ngraph TD\n    IaaS[IaaS - Infra] --> PaaS[PaaS - Platform]\n    PaaS --> SaaS[SaaS - Software]\n    FaaS[FaaS - Serverless]\n"
  },
  {
    "id": "gh-16",
    "question": "What is Infrastructure as Code?",
    "answer": "Infrastructure as Code (IaC) is the practice of managing and provisioning infrastructure through machine-readable definition files rather than physica...",
    "explanation": "Infrastructure as Code (IaC) is the practice of managing and provisioning infrastructure through machine-readable definition files rather than physical hardware configuration or interactive configuration tools.\n\nBenefits of IaC:\n- Version Control\n- Reproducibility\n- Automation\n- Documentation\n- Consistency\n- Scalability",
    "tags": [
      "iac",
      "terraform",
      "ansible"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "terraform",
    "diagram": "\ngraph LR\n    Code[Code Files] --> VCS[Version Control]\n    VCS --> Apply[Apply Changes]\n    Apply --> Infra[Infrastructure]\n"
  },
  {
    "id": "gh-17",
    "question": "What is Terraform?",
    "answer": "Terraform is an open-source IaC software tool that enables you to safely and predictably create, change, and improve infrastructure. It codifies cloud...",
    "explanation": "Terraform is an open-source IaC software tool that enables you to safely and predictably create, change, and improve infrastructure. It codifies cloud APIs into declarative configuration files.\n\nExample of a simple Terraform configuration:\n```hcl\nprovider \"aws\" {\nregion = \"us-west-2\"\n}\n\nresource \"aws_instance\" \"example\" {\nami           = \"ami-0c55b159cbfafe1f0\"\ninstance_type = \"t2.micro\"\n\ntags = {\nName = \"example-instance\"\n}\n}\n```",
    "tags": [
      "iac",
      "terraform",
      "ansible"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "terraform",
    "diagram": "\ngraph LR\n    HCL[.tf Files] --> Plan[terraform plan]\n    Plan --> Apply[terraform apply]\n    Apply --> Cloud[Cloud Resources]\n"
  },
  {
    "id": "gh-18",
    "question": "What is Ansible?",
    "answer": "Ansible is an open-source automation tool that automates software provisioning, configuration management, and application deployment. It uses YAML syn...",
    "explanation": "Ansible is an open-source automation tool that automates software provisioning, configuration management, and application deployment. It uses YAML syntax for expressing automation jobs.\n\nExample of an Ansible playbook:\n```yaml\n---\n- name: Install and configure web server\nhosts: webservers\nbecome: yes\n\ntasks:\n- name: Install nginx\napt:\nname: nginx\nstate: present\n\n- name: Start nginx service\nservice:\nname: nginx\nstate: started\n```",
    "tags": [
      "iac",
      "terraform",
      "ansible"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "terraform",
    "diagram": "\ngraph LR\n    Playbook[Playbook] --> Inventory[Inventory]\n    Inventory --> SSH[SSH]\n    SSH --> Servers[Servers]\n"
  },
  {
    "id": "gh-19",
    "question": "What is monitoring in DevOps?",
    "answer": "Monitoring in DevOps is the practice of collecting and analyzing data about the performance and stability of services and infrastructure to improve th...",
    "explanation": "Monitoring in DevOps is the practice of collecting and analyzing data about the performance and stability of services and infrastructure to improve the system's reliability. Key aspects include:\n\n1. **Infrastructure Monitoring:**\n- Server health\n- Network performance\n- Resource utilization\n\n2. **Application Monitoring:**\n- Response times\n- Error rates\n- Request rates\n\n3. **User Experience Monitoring:**\n- Page load times\n- User interactions\n- Conversion rates",
    "tags": [
      "observability",
      "monitoring",
      "logging"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "observability",
    "diagram": "\ngraph TD\n    App[Application] --> Metrics[Metrics]\n    Infra[Infrastructure] --> Metrics\n    Metrics --> Dashboard[Dashboard]\n    Dashboard --> Alerts[Alerts]\n"
  },
  {
    "id": "gh-20",
    "question": "What is ELK Stack?",
    "answer": "ELK Stack is a collection of three open-source products:",
    "explanation": "ELK Stack is a collection of three open-source products:\n\n1. **Elasticsearch:** A search and analytics engine\n2. **Logstash:** A server‑side data processing pipeline\n3. **Kibana:** A visualization tool for Elasticsearch data\n\nCommon use cases:\n- Log aggregation\n- Security analytics\n- Application performance monitoring\n- Website search\n- Business analytics",
    "tags": [
      "observability",
      "monitoring",
      "logging"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "observability",
    "diagram": "\ngraph LR\n    Logs[Logs] --> Logstash[Logstash]\n    Logstash --> ES[(Elasticsearch)]\n    ES --> Kibana[Kibana]\n"
  },
  {
    "id": "gh-21",
    "question": "What is Prometheus?",
    "answer": "Prometheus is an open-source systems monitoring and alerting toolkit. Key features include:",
    "explanation": "Prometheus is an open-source systems monitoring and alerting toolkit. Key features include:\n\n1. **Time series database**\n2. **Flexible query language (PromQL)**\n3. **Pull-based metrics collection**\n4. **Alert management**\n5. **Visualization capabilities**\n\nExample of Prometheus configuration:\n```yaml\nglobal:\nscrape_interval: 15s\n\nscrape_configs:\n- job_name: 'prometheus'\nstatic_configs:\n- targets: ['localhost:9090']\n\n- job_name: 'node'\nstatic_configs:\n- targets: ['localhost:9100']\n```",
    "tags": [
      "observability",
      "monitoring",
      "logging"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "observability",
    "diagram": "\ngraph LR\n    Targets[Targets] --> Prom[Prometheus]\n    Prom --> TSDB[(Time Series DB)]\n    Prom --> Alert[Alertmanager]\n"
  },
  {
    "id": "gh-22",
    "question": "What is Grafana?",
    "answer": "Grafana is an open-source analytics and monitoring solution that allows you to query, visualize, and alert on your metrics no matter where they are st...",
    "explanation": "Grafana is an open-source analytics and monitoring solution that allows you to query, visualize, and alert on your metrics no matter where they are stored. Key features include:\n\n1. **Data source integration**\n2. **Dashboard creation**\n3. **Alerting**\n4. **Visualization**\n5. **User interface**",
    "tags": [
      "observability",
      "monitoring",
      "logging"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "observability",
    "diagram": "\ngraph LR\n    DS1[(Prometheus)] --> Grafana\n    DS2[(InfluxDB)] --> Grafana\n    Grafana --> Dash[Dashboards]\n"
  },
  {
    "id": "gh-23",
    "question": "Explain the difference between monitoring and logging",
    "answer": "Monitoring and logging are two different practices in DevOps:",
    "explanation": "Monitoring and logging are two different practices in DevOps:\n\n1. **Monitoring:**\n- Focuses on collecting and analyzing data about the performance and stability of services and infrastructure to improve the system's reliability.\n- Key aspects include:\n- Infrastructure Monitoring\n- Application Monitoring\n- User Experience Monitoring\n\n2. **Logging:**\n- Focuses on collecting and analyzing log data to help diagnose and troubleshoot issues.\n- Key aspects include:\n- Log aggregation\n- Security analytics\n- Application performance monitoring\n- Website search\n- Business analytics",
    "tags": [
      "observability",
      "monitoring",
      "logging"
    ],
    "difficulty": "intermediate",
    "channel": "devops",
    "subChannel": "observability",
    "diagram": "\ngraph TD\n    subgraph Monitoring\n    M[Metrics] --> Dash[Dashboard]\n    end\n    subgraph Logging\n    L[Logs] --> Search[Search/Analyze]\n    end\n"
  },
  {
    "id": "gh-24",
    "question": "What is DevSecOps?",
    "answer": "DevSecOps is the practice of integrating security practices within the DevOps process. It creates a 'security as code' culture with ongoing, flexible ...",
    "explanation": "DevSecOps is the practice of integrating security practices within the DevOps process. It creates a 'security as code' culture with ongoing, flexible collaboration between release engineers and security teams.\n\nKey principles include:\n- Security automation\n- Early security testing\n- Continuous security monitoring\n- Security as part of CI/CD pipeline\n- Rapid security feedback",
    "tags": [
      "security",
      "devsecops"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "security",
    "diagram": "\ngraph LR\n    Dev --> Sec[Security]\n    Sec --> Ops\n    Ops --> Dev\n"
  },
  {
    "id": "gh-25",
    "question": "What is Infrastructure Security?",
    "answer": "Infrastructure Security involves securing all infrastructure components including:",
    "explanation": "Infrastructure Security involves securing all infrastructure components including:\n\n1. **Network Security:**\n- Firewalls\n- VPNs\n- Network segmentation\n- DDoS protection\n\n2. **Cloud Security:**\n- Identity and Access Management (IAM)\n- Encryption\n- Security groups\n- Network ACLs\n\n3. **Host Security:**\n- OS hardening\n- Patch management\n- Antivirus\n- Host-based firewalls",
    "tags": [
      "security",
      "devsecops"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "security",
    "diagram": "\ngraph TD\n    Infra[Infrastructure] --> Net[Network Security]\n    Infra --> Cloud[Cloud Security]\n    Infra --> Host[Host Security]\n"
  },
  {
    "id": "gh-26",
    "question": "What are the basic Linux commands every DevOps engineer should know?",
    "answer": "Essential Linux commands include:",
    "explanation": "Essential Linux commands include:\n\n1. **File Operations:**\n```bash\nls      # List files and directories\ncd      # Change directory\npwd     # Print working directory\ncp      # Copy files\nmv      # Move/rename files\nrm      # Remove files\nmkdir   # Create directory\n```\n\n2. **System Information:**\n```bash\ntop     # Show processes\ndf      # Show disk usage\nfree    # Show memory usage\nps      # Show process status\n```\n\n3. **Text Processing:**\n```bash\ngrep    # Search text\nsed     # Stream editor\nawk     # Text processing\ncat     # View file contents\n```",
    "tags": [
      "linux",
      "shell"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "linux",
    "diagram": "\ngraph TD\n    Linux --> Files[File Ops: ls, cp, mv]\n    Linux --> Sys[System: top, df, ps]\n    Linux --> Text[Text: grep, awk, sed]\n"
  },
  {
    "id": "gh-27",
    "question": "What is Git?",
    "answer": "Git is a distributed version control system that tracks changes in source code during software development. It's designed for coordinating work among ...",
    "explanation": "Git is a distributed version control system that tracks changes in source code during software development. It's designed for coordinating work among programmers, but it can be used to track changes in any set of files.\n\nKey concepts include:\n- Repository\n- Commit\n- Branch\n- Merge\n- Pull Request\n- Clone\n- Push/Pull",
    "tags": [
      "git",
      "vcs"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "git",
    "diagram": "\ngraph LR\n    Local[Local Repo] --> Push[Push]\n    Push --> Remote[Remote Repo]\n    Remote --> Pull[Pull]\n    Pull --> Local\n"
  },
  {
    "id": "gh-28",
    "question": "What is Git Branching Strategy?",
    "answer": "A Git branching strategy is a convention or set of rules that specify how and when branches should be created and merged. Common strategies include:",
    "explanation": "A Git branching strategy is a convention or set of rules that specify how and when branches should be created and merged. Common strategies include:\n\n1. **Git Flow:**\n- Main branches: master, develop\n- Supporting branches: feature, release, hotfix\n\n2. **Trunk-Based Development:**\n- Single main branch (trunk)\n- Short-lived feature branches\n- Frequent integration\n\nExample of creating a feature branch:\n```bash\n# Create and switch to a new feature branch\ngit checkout -b feature/new-feature\n\n# Make changes and commit\ngit add .\ngit commit -m \"Add new feature\"\n\n# Push to remote\ngit push origin feature/new-feature\n```",
    "tags": [
      "git",
      "vcs"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "git",
    "diagram": "\ngraph LR\n    Main[main] --> Dev[develop]\n    Dev --> Feat[feature]\n    Feat --> Dev\n    Dev --> Main\n"
  },
  {
    "id": "gh-29",
    "question": "What is Configuration Management?",
    "answer": "Configuration Management is the process of maintaining systems, such as computer systems and servers, in a desired state. It's a way to make sure that...",
    "explanation": "Configuration Management is the process of maintaining systems, such as computer systems and servers, in a desired state. It's a way to make sure that a system performs as it's supposed to as changes are made over time.\n\nKey aspects include:\n- System configuration\n- Application configuration\n- Dependencies management\n- Version control\n- Compliance and security",
    "tags": [
      "config-mgmt",
      "ansible",
      "chef"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "ansible",
    "diagram": "\ngraph LR\n    Config[Config Code] --> Tool[CM Tool]\n    Tool --> S1[Server 1]\n    Tool --> S2[Server 2]\n"
  },
  {
    "id": "gh-30",
    "question": "What is Puppet?",
    "answer": "Puppet is a configuration management tool that helps you automate the provisioning and management of your infrastructure. It uses a declarative langua...",
    "explanation": "Puppet is a configuration management tool that helps you automate the provisioning and management of your infrastructure. It uses a declarative language to describe system configurations.\n\nExample of a Puppet manifest:\n```puppet\nclass apache {\npackage { 'apache2':\nensure => installed,\n}\n\nservice { 'apache2':\nensure => running,\nenable => true,\nrequire => Package['apache2'],\n}\n\nfile { '/var/www/html/index.html':\nensure => file,\ncontent => 'Hello, World!',\nrequire => Package['apache2'],\n}\n}\n```",
    "tags": [
      "config-mgmt",
      "ansible",
      "chef"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "ansible"
  },
  {
    "id": "gh-31",
    "question": "What is Scalability in DevOps?",
    "answer": "Scalability is the capability of a system to handle a growing amount of work by adding resources to the system. There are two types of scaling:",
    "explanation": "Scalability is the capability of a system to handle a growing amount of work by adding resources to the system. There are two types of scaling:\n\n1. **Vertical Scaling (Scale Up):**\n- Adding more power to existing resources\n- Example: Upgrading CPU/RAM\n\n2. **Horizontal Scaling (Scale Out):**\n- Adding more resources\n- Example: Adding more servers",
    "tags": [
      "scale",
      "ha"
    ],
    "difficulty": "advanced",
    "channel": "system-design",
    "subChannel": "infrastructure",
    "diagram": "\ngraph TD\n    subgraph Vertical\n    S1[Small] --> S2[Large]\n    end\n    subgraph Horizontal\n    H1[Server] --- H2[Server] --- H3[Server]\n    end\n"
  },
  {
    "id": "gh-32",
    "question": "What is High Availability?",
    "answer": "High Availability (HA) is a characteristic of a system that aims to ensure an agreed level of operational performance, usually uptime, for a higher th...",
    "explanation": "High Availability (HA) is a characteristic of a system that aims to ensure an agreed level of operational performance, usually uptime, for a higher than normal period.\n\nKey components:\n1. **Redundancy:**\n- Multiple instances\n- No single point of failure\n\n2. **Monitoring:**\n- Health checks\n- Automated failover\n\n3. **Load Balancing:**\n- Traffic distribution\n- Resource optimization",
    "tags": [
      "scale",
      "ha"
    ],
    "difficulty": "advanced",
    "channel": "system-design",
    "subChannel": "infrastructure",
    "diagram": "\ngraph TD\n    LB[Load Balancer] --> S1[Server 1]\n    LB --> S2[Server 2]\n    S1 -.->|Failover| S2\n"
  },
  {
    "id": "gh-33",
    "question": "What is Load Balancing?",
    "answer": "Load Balancing is the process of distributing network traffic across multiple servers to ensure no single server bears too much demand.",
    "explanation": "Load Balancing is the process of distributing network traffic across multiple servers to ensure no single server bears too much demand.\n\nCommon Load Balancing algorithms:\n1. **Round Robin**\n2. **Least Connections**\n3. **IP Hash**\n4. **Weighted Round Robin**\n5. **Resource-Based**\n\nExample of Nginx Load Balancer configuration:\n```nginx\nhttp {\nupstream backend {\nserver backend1.example.com;\nserver backend2.example.com;\nserver backend3.example.com;\n}\n\nserver {\nlisten 80;\nlocation / {\nproxy_pass http://backend;\n}\n}\n}\n```",
    "tags": [
      "scale",
      "ha"
    ],
    "difficulty": "advanced",
    "channel": "system-design",
    "subChannel": "infrastructure"
  },
  {
    "id": "gh-34",
    "question": "What is Auto Scaling?",
    "answer": "Auto Scaling is a feature that automatically adjusts the number of compute resources based on the current demand.",
    "explanation": "Auto Scaling is a feature that automatically adjusts the number of compute resources based on the current demand.\n\nKey concepts:\n1. **Scaling Policies:**\n- Target tracking\n- Step scaling\n- Simple scaling\n\n2. **Metrics:**\n- CPU utilization\n- Memory usage\n- Request count\n- Custom metrics\n\nExample of AWS Auto Scaling configuration:\n```yaml\nAutoScalingGroup:\nMinSize: 1\nMaxSize: 10\nDesiredCapacity: 2\nHealthCheckType: ELB\nHealthCheckGracePeriod: 300\nLaunchTemplate:\nLaunchTemplateId: !Ref LaunchTemplate\nVersion: !GetAtt LaunchTemplate.LatestVersionNumber\n```",
    "tags": [
      "scale",
      "ha"
    ],
    "difficulty": "advanced",
    "channel": "system-design",
    "subChannel": "infrastructure",
    "diagram": "\ngraph LR\n    Metrics[Metrics] --> ASG[Auto Scaling]\n    ASG -->|Scale Out| Add[Add Instances]\n    ASG -->|Scale In| Remove[Remove Instances]\n"
  },
  {
    "id": "gh-35",
    "question": "What is Backup and Disaster Recovery?",
    "answer": "Backup and Disaster Recovery (BDR) is a combination of data backup and disaster recovery solutions that work together to ensure an organization's busi...",
    "explanation": "Backup and Disaster Recovery (BDR) is a combination of data backup and disaster recovery solutions that work together to ensure an organization's business continuity.\n\nKey components:\n1. **Data Backup:**\n- Regular data copies\n- Multiple backup locations\n- Automated backup processes\n\n2. **Disaster Recovery:**\n- Recovery procedures\n- Failover systems\n- Business continuity plans",
    "tags": [
      "backup",
      "dr"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-36",
    "question": "What are different types of backups?",
    "answer": "Common backup types include:",
    "explanation": "Common backup types include:\n\n1. **Full Backup:**\n- Complete copy of all data\n- Most time and space consuming\n- Fastest restore time\n\n2. **Incremental Backup:**\n- Only backs up changes since last backup\n- Faster and requires less storage\n- Longer restore time\n\n3. **Differential Backup:**\n- Backs up changes since last full backup\n- Balance between full and incremental\n- Medium restore time",
    "tags": [
      "backup",
      "dr"
    ],
    "difficulty": "intermediate",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-37",
    "question": "What is Cloud Native Architecture?",
    "answer": "Cloud Native Architecture is an approach to designing and building applications that exploits the advantages of the cloud computing delivery model. It...",
    "explanation": "Cloud Native Architecture is an approach to designing and building applications that exploits the advantages of the cloud computing delivery model. It emphasizes:\n\n1. **Characteristics:**\n- Scalability\n- Containerization\n- Automation\n- Orchestration\n- Microservices\n\n2. **Key Principles:**\n- Design for automation\n- Build for resilience\n- Enable scalability\n- Embrace containerization\n- Practice continuous delivery",
    "tags": [
      "cloud-native",
      "microservices"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "general",
    "diagram": "\ngraph TD\n    Cloud[Cloud Native] --> Containers\n    Cloud --> Microservices\n    Cloud --> K8s[Orchestration]\n    Cloud --> CI[CI/CD]\n"
  },
  {
    "id": "gh-38",
    "question": "What are Microservices?",
    "answer": "Microservices is an architectural style that structures an application as a collection of small autonomous services, modeled around a business domain.",
    "explanation": "Microservices is an architectural style that structures an application as a collection of small autonomous services, modeled around a business domain.\n\nKey characteristics:\n1. **Independence:**\n- Separate codebases\n- Independent deployment\n- Different technology stacks\n\n2. **Communication:**\n- API-based interaction\n- Event-driven\n- Service discovery\n\nExample of a microservice API:\n```yaml\nopenapi: 3.0.0\ninfo:\ntitle: User Service API\nversion: 1.0.0\npaths:\n/users:\nget:\nsummary: List users\nresponses:\n'200':\ndescription: List of users\npost:\nsummary: Create user\nresponses:\n'201':\ndescription: User created\n```",
    "tags": [
      "cloud-native",
      "microservices"
    ],
    "difficulty": "intermediate",
    "channel": "devops",
    "subChannel": "general",
    "diagram": "\ngraph LR\n    API[API Gateway] --> User[User Service]\n    API --> Order[Order Service]\n    API --> Pay[Payment Service]\n"
  },
  {
    "id": "gh-39",
    "question": "What is Service Mesh?",
    "answer": "A service mesh is a dedicated infrastructure layer for handling service-to-service communication in microservices architectures.",
    "explanation": "A service mesh is a dedicated infrastructure layer for handling service-to-service communication in microservices architectures.\n\nKey components:\n1. **Data Plane:**\n- Service proxies (sidecars)\n- Traffic handling\n- Security enforcement\n\n2. **Control Plane:**\n- Configuration management\n- Policy enforcement\n- Service discovery\n\nExample of Istio configuration:\n```yaml\napiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\nname: reviews-route\nspec:\nhosts:\n- reviews\nhttp:\n- route:\n- destination:\nhost: reviews\nsubset: v1\nweight: 75\n- destination:\nhost: reviews\nsubset: v2\nweight: 25\n```",
    "tags": [
      "cloud-native",
      "microservices"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "general",
    "diagram": "\ngraph TD\n    CP[Control Plane] --> DP[Data Plane]\n    DP --> S1[Sidecar] --> Svc1[Service 1]\n    DP --> S2[Sidecar] --> Svc2[Service 2]\n"
  },
  {
    "id": "gh-40",
    "question": "What is Performance Testing?",
    "answer": "Performance Testing is a type of testing to determine how a system performs in terms of responsiveness and stability under various workload conditions...",
    "explanation": "Performance Testing is a type of testing to determine how a system performs in terms of responsiveness and stability under various workload conditions.\n\nKey aspects include:\n1. **Performance Metrics:**\n- Response time\n- Throughput\n- Resource utilization\n- Scalability\n- Reliability\n\n2. **Testing Goals:**\n- Identify bottlenecks\n- Determine system capacity\n- Validate performance requirements\n- Benchmark performance",
    "tags": [
      "perf",
      "testing"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-41",
    "question": "What are different types of Performance Tests?",
    "answer": "Common types of performance tests include:",
    "explanation": "Common types of performance tests include:\n\n1. **Load Testing:**\n- Tests system behavior under specific load\n- Validates system performance under expected conditions\n\n2. **Stress Testing:**\n- Tests system behavior under peak load\n- Identifies breaking points\n\n3. **Endurance Testing:**\n- Tests system behavior over extended periods\n- Identifies memory leaks and resource issues\n\nExample of JMeter test plan:\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<jmeterTestPlan version=\"1.2\">\n<hashTree>\n<TestPlan>\n<elementProp name=\"TestPlan.user_defined_variables\">\n<collectionProp name=\"Arguments.arguments\"/>\n</elementProp>\n<stringProp name=\"TestPlan.comments\"></stringProp>\n<boolProp name=\"TestPlan.functional_mode\">false</boolProp>\n<boolProp name=\"TestPlan.serialize_threadgroups\">false</boolProp>\n</TestPlan>\n</hashTree>\n</jmeterTestPlan>\n```",
    "tags": [
      "perf",
      "testing"
    ],
    "difficulty": "intermediate",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-42",
    "question": "What is an API Gateway?",
    "answer": "An API Gateway acts as a reverse proxy to accept all API calls, aggregate various services, and return the appropriate result.",
    "explanation": "An API Gateway acts as a reverse proxy to accept all API calls, aggregate various services, and return the appropriate result.\n\nKey features:\n1. **Request Handling:**\n- Authentication\n- SSL termination\n- Rate limiting\n\n2. **Integration:**\n- Service discovery\n- Request routing\n- Response transformation\n\nExample of Kong API Gateway configuration:\n```yaml\nservices:\n- name: user-service\nurl: http://user-service:8000\nroutes:\n- name: user-route\npaths:\n- /users\nplugins:\n- name: rate-limiting\nconfig:\nminute: 5\npolicy: local\n```",
    "tags": [
      "api",
      "service-mesh"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "general",
    "diagram": "\ngraph LR\n    Client --> GW[API Gateway]\n    GW --> Auth[Auth Service]\n    GW --> User[User Service]\n    GW --> Data[Data Service]\n"
  },
  {
    "id": "gh-43",
    "question": "What are the benefits of using API Gateway?",
    "answer": "Key benefits include:",
    "explanation": "Key benefits include:\n\n1. **Security:**\n- Centralized authentication\n- Authorization\n- SSL/TLS termination\n\n2. **Performance:**\n- Caching\n- Request/Response transformation\n- Load balancing\n\n3. **Monitoring:**\n- Analytics\n- Logging\n- Rate limiting",
    "tags": [
      "api",
      "service-mesh"
    ],
    "difficulty": "intermediate",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-44",
    "question": "What is API Security?",
    "answer": "API Security involves protecting APIs from threats and vulnerabilities while ensuring they remain accessible to authorized users.",
    "explanation": "API Security involves protecting APIs from threats and vulnerabilities while ensuring they remain accessible to authorized users.\n\nKey security measures:\n1. **Authentication:**\n- API keys\n- OAuth 2.0\n- JWT tokens\n\n2. **Authorization:**\n- Role-based access control\n- Scope-based access\n- Resource-level permissions\n\nExample of OAuth2 configuration:\n```yaml\nsecurity:\noauth2:\nclient:\nclientId: ${CLIENT_ID}\nclientSecret: ${CLIENT_SECRET}\nresource:\ntokenInfoUri: https://api.auth.com/oauth/check_token\n```",
    "tags": [
      "api",
      "service-mesh"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-45",
    "question": "What is Rate Limiting?",
    "answer": "Rate Limiting is a technique used to control the rate at which requests are processed or transmitted.",
    "explanation": "Rate Limiting is a technique used to control the rate at which requests are processed or transmitted.\n\nKey concepts:\n1. **Token Bucket Algorithm:**\n- Fixed number of tokens\n- Tokens are replenished at a fixed rate\n- Tokens are consumed at a variable rate\n\n2. **Leaky Bucket Algorithm:**\n- Fixed size bucket\n- Water leaks out at a fixed rate\n- Water is added at a variable rate\n\nExample of Nginx Rate Limiting configuration:\n```nginx\nhttp {\nlimit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;\n\nserver {\nlocation / {\nlimit_req burst=5 nodelay;\n}\n}\n}\n```",
    "tags": [
      "api",
      "service-mesh"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-46",
    "question": "What is API Documentation?",
    "answer": "API Documentation is a set of documents that describe how to use an API. It includes:",
    "explanation": "API Documentation is a set of documents that describe how to use an API. It includes:\n\n1. **API Reference:**\n- Detailed description of each API endpoint\n- Request and response formats\n- Example requests and responses\n\n2. **API Usage Examples:**\n- Code samples\n- API client libraries\n- API testing tools\n\nExample of Swagger API Documentation:\n```yaml\nswagger: '2.0'\ninfo:\ntitle: User Service API\nversion: 1.0.0\npaths:\n/users:\nget:\nsummary: List users\nresponses:\n'200':\ndescription: List of users\npost:\nsummary: Create user\nresponses:\n'201':\ndescription: User created\n```",
    "tags": [
      "api",
      "service-mesh"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-47",
    "question": "What are StatefulSets in Kubernetes?",
    "answer": "StatefulSets are used to manage stateful applications, providing guarantees about the ordering and uniqueness of Pods.",
    "explanation": "StatefulSets are used to manage stateful applications, providing guarantees about the ordering and uniqueness of Pods.\n\nKey features:\n1. **Stable Network Identity:**\n- Predictable Pod names\n- Stable hostnames\n\n2. **Ordered Deployment:**\n- Sequential creation\n- Sequential scaling\n- Sequential deletion\n\nExample of StatefulSet:\n```yaml\napiVersion: apps/v1\nkind: StatefulSet\nmetadata:\nname: web\nspec:\nserviceName: \"nginx\"\nreplicas: 3\nselector:\nmatchLabels:\napp: nginx\ntemplate:\nmetadata:\nlabels:\napp: nginx\nspec:\ncontainers:\n- name: nginx\nimage: nginx:1.14.2\nports:\n- containerPort: 80\nvolumeMounts:\n- name: www\nmountPath: /usr/share/nginx/html\nvolumeClaimTemplates:\n- metadata:\nname: www\nspec:\naccessModes: [ \"ReadWriteOnce\" ]\nresources:\nrequests:\nstorage: 1Gi\n```",
    "tags": [
      "k8s",
      "advanced"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "kubernetes"
  },
  {
    "id": "gh-48",
    "question": "What are DaemonSets in Kubernetes?",
    "answer": "DaemonSets ensure that all (or some) nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them.",
    "explanation": "DaemonSets ensure that all (or some) nodes run a copy of a Pod. As nodes are added to the cluster, Pods are added to them.\n\nUse cases:\n1. **Monitoring Agents**\n2. **Log Collectors**\n3. **Node-level Storage**\n4. **Network Plugins**\n\nExample of DaemonSet:\n```yaml\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\nname: fluentd-elasticsearch\nspec:\nselector:\nmatchLabels:\nname: fluentd-elasticsearch\ntemplate:\nmetadata:\nlabels:\nname: fluentd-elasticsearch\nspec:\ncontainers:\n- name: fluentd-elasticsearch\nimage: quay.io/fluentd_elasticsearch/fluentd:v2.5.2\n```",
    "tags": [
      "k8s",
      "advanced"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "kubernetes"
  },
  {
    "id": "gh-49",
    "question": "What is Helm?",
    "answer": "Helm is a package manager for Kubernetes that helps you manage Kubernetes applications through Helm Charts.",
    "explanation": "Helm is a package manager for Kubernetes that helps you manage Kubernetes applications through Helm Charts.\n\nKey concepts:\n1. **Charts:**\n- Package format\n- Collection of files\n- Template mechanism\n\n2. **Repositories:**\n- Chart storage\n- Version control\n- Distribution\n\nExample of Helm Chart:\n```yaml\napiVersion: v2\nname: my-app\ndescription: A Helm chart for my application\nversion: 0.1.0\ndependencies:\n- name: mysql\nversion: 8.8.3\nrepository: https://charts.bitnami.com/bitnami\n```",
    "tags": [
      "k8s",
      "advanced"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "kubernetes",
    "diagram": "\ngraph LR\n    Chart[Helm Chart] --> Helm[Helm CLI]\n    Helm --> K8s[Kubernetes]\n    K8s --> App[Application]\n"
  },
  {
    "id": "gh-50",
    "question": "What is Istio?",
    "answer": "Istio is an open-source service mesh that provides a way to control how services communicate with one another. It includes:",
    "explanation": "Istio is an open-source service mesh that provides a way to control how services communicate with one another. It includes:\n\n1. **Traffic Management:**\n- Load balancing\n- Traffic routing\n- Fault injection\n- Traffic mirroring\n\n2. **Security:**\n- Authentication\n- Authorization\n- Encryption\n- Mutual TLS\n\n3. **Observability:**\n- Telemetry\n- Metrics\n- Tracing\n- Logging",
    "tags": [
      "k8s",
      "advanced"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "kubernetes"
  },
  {
    "id": "gh-51",
    "question": "What is Container Runtime Interface (CRI)?",
    "answer": "Container Runtime Interface (CRI) is an API that allows container runtimes to interact with the container orchestrator. It includes:",
    "explanation": "Container Runtime Interface (CRI) is an API that allows container runtimes to interact with the container orchestrator. It includes:\n\n1. **Image Management:**\n- Pulling images\n- Pushing images\n- Listing images\n- Deleting images\n\n2. **Container Management:**\n- Creating containers\n- Starting containers\n- Stopping containers\n- Killing containers\n- Inspecting containers\n\n3. **Container Runtime:**\n- Running containers\n- Pausing containers\n- Resuming containers\n- Executing commands in containers",
    "tags": [
      "k8s",
      "advanced"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "kubernetes"
  },
  {
    "id": "gh-52",
    "question": "What is Infrastructure Automation?",
    "answer": "Infrastructure Automation is the process of scripting environments - from installing an operating system, to installing and configuring servers on ins...",
    "explanation": "Infrastructure Automation is the process of scripting environments - from installing an operating system, to installing and configuring servers on instances, to configuring how the instances and software communicate with one another.\n\nKey components:\n1. **Provisioning:**\n- Resource creation\n- Configuration management\n- Application deployment\n\n2. **Orchestration:**\n- Workflow automation\n- Service coordination\n- Resource scheduling",
    "tags": [
      "automation",
      "tools"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-53",
    "question": "What is GitOps?",
    "answer": "GitOps is a way of implementing Continuous Deployment for cloud native applications. It focuses on a developer-centric experience when operating infra...",
    "explanation": "GitOps is a way of implementing Continuous Deployment for cloud native applications. It focuses on a developer-centric experience when operating infrastructure, by using tools developers are already familiar with, including Git and Continuous Deployment tools.\n\nPrinciples:\n1. **Declarative:**\n- Infrastructure as code\n- Application configuration as code\n\n2. **Version Controlled:**\n- Git as single source of truth\n- Audit trail for changes\n\n3. **Automated:**\n- Pull-based deployment\n- Continuous reconciliation",
    "tags": [
      "automation",
      "tools"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "general",
    "diagram": "\ngraph LR\n    Git[Git Repo] --> Operator[GitOps Operator]\n    Operator --> K8s[Kubernetes]\n    K8s --> App[Application]\n"
  },
  {
    "id": "gh-54",
    "question": "What is ArgoCD?",
    "answer": "ArgoCD is a declarative, GitOps continuous delivery tool for Kubernetes. It allows you to declaratively manage your Kubernetes applications by using G...",
    "explanation": "ArgoCD is a declarative, GitOps continuous delivery tool for Kubernetes. It allows you to declaratively manage your Kubernetes applications by using Git repositories as the source of truth.\n\nKey features:\n1. **Declarative:**\n- Infrastructure as code\n- Application configuration as code\n\n2. **Version Controlled:**\n- Git as single source of truth\n- Audit trail for changes\n\n3. **Automated:**\n- Pull-based deployment\n- Continuous reconciliation",
    "tags": [
      "automation",
      "tools"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "general",
    "diagram": "\ngraph LR\n    Git[Git] --> Argo[ArgoCD]\n    Argo --> Sync[Sync]\n    Sync --> K8s[Kubernetes]\n"
  },
  {
    "id": "gh-55",
    "question": "What is Tekton?",
    "answer": "Tekton is an open-source, cloud-native CI/CD framework that allows you to define, run, and observe CI/CD pipelines. It's designed to be extensible and...",
    "explanation": "Tekton is an open-source, cloud-native CI/CD framework that allows you to define, run, and observe CI/CD pipelines. It's designed to be extensible and can be used with any container runtime.\n\nKey features:\n1. **Extensible:**\n- Custom tasks\n- Custom resources\n- Custom pipelines\n\n2. **Cloud-native:**\n- Container-based\n- Kubernetes-native\n- Serverless-friendly",
    "tags": [
      "automation",
      "tools"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-56",
    "question": "What are Deployment Strategies?",
    "answer": "Deployment Strategies are methods used to deploy applications to Kubernetes clusters. Common strategies include:",
    "explanation": "Deployment Strategies are methods used to deploy applications to Kubernetes clusters. Common strategies include:\n\n1. **Blue-Green Deployment:**\n- Deploy a new version of the application\n- Traffic is routed to the new version\n- Old version is kept running\n\n2. **Canary Deployment:**\n- Deploy a new version of the application\n- Traffic is routed to the new version\n- Old version is kept running\n\n3. **Rolling Update:**\n- Deploy a new version of the application\n- Old version is gradually replaced\n- Traffic is routed to the new version\n\n4. **Blue-Green with Rolling Update:**\n- Deploy a new version of the application\n- Traffic is routed to the new version\n- Old version is gradually replaced",
    "tags": [
      "automation",
      "tools"
    ],
    "difficulty": "intermediate",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-57",
    "question": "What is Cloud Cost Optimization?",
    "answer": "Cloud Cost Optimization is the process of reducing your overall cloud spend by identifying mismanaged resources, eliminating waste, reserving capacity...",
    "explanation": "Cloud Cost Optimization is the process of reducing your overall cloud spend by identifying mismanaged resources, eliminating waste, reserving capacity for higher discounts, and right-sizing computing services to scale.\n\nKey strategies include:\n1. **Resource Optimization:**\n- Right-sizing instances\n- Shutting down unused resources\n- Using auto-scaling effectively\n\n2. **Pricing Optimization:**\n- Reserved Instances\n- Spot Instances\n- Savings Plans",
    "tags": [
      "finops",
      "cost"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-58",
    "question": "What are Reserved Instances?",
    "answer": "Reserved Instances (RIs) provide a significant discount compared to On-Demand pricing in exchange for a commitment to use a specific instance configur...",
    "explanation": "Reserved Instances (RIs) provide a significant discount compared to On-Demand pricing in exchange for a commitment to use a specific instance configuration for a one or three-year term.\n\nTypes of RIs:\n```yaml\nStandard RIs:\n- Highest discount (up to 75%)\n- Least flexibility\n- Best for steady-state workloads\n\nConvertible RIs:\n- Lower discount (up to 54%)\n- More flexibility\n- Can change instance family, OS, tenancy\n\nScheduled RIs:\n- For predictable recurring schedules\n- Match capacity reservation to usage pattern\n```",
    "tags": [
      "finops",
      "cost"
    ],
    "difficulty": "intermediate",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-59",
    "question": "What is Site Reliability Engineering?",
    "answer": "Site Reliability Engineering (SRE) is a discipline that incorporates aspects of software engineering and applies them to infrastructure and operations...",
    "explanation": "Site Reliability Engineering (SRE) is a discipline that incorporates aspects of software engineering and applies them to infrastructure and operations problems to create scalable and highly reliable software systems.\n\nKey principles:\n1. **Embrace Risk:**\n- Define acceptable risk levels\n- Use error budgets\n- Balance reliability and innovation\n\n2. **Eliminate Toil:**\n- Automate manual tasks\n- Reduce operational overhead\n- Focus on engineering work",
    "tags": [
      "sre",
      "reliability"
    ],
    "difficulty": "beginner",
    "channel": "sre",
    "subChannel": "reliability"
  },
  {
    "id": "gh-60",
    "question": "What are Service Level Objectives (SLOs)?",
    "answer": "Service Level Objectives (SLOs) are specific, measurable targets for service performance that you set and agree to meet.",
    "explanation": "Service Level Objectives (SLOs) are specific, measurable targets for service performance that you set and agree to meet.\n\nExample SLO definition:\n```yaml\nService: User Authentication\nSLO:\nMetric: Availability\nTarget: 99.9%\nWindow: 30 days\nMeasurement:\n- Success rate of authentication requests\n- Latency under 300ms for 99% of requests\n```",
    "tags": [
      "sre",
      "reliability"
    ],
    "difficulty": "intermediate",
    "channel": "sre",
    "subChannel": "reliability"
  },
  {
    "id": "gh-61",
    "question": "What are Service Level Indicators (SLIs)?",
    "answer": "Service Level Indicators (SLIs) are quantitative measures of service level aspects such as latency, throughput, availability, and error rate.",
    "explanation": "Service Level Indicators (SLIs) are quantitative measures of service level aspects such as latency, throughput, availability, and error rate.\n\nCommon SLIs:\n1. **Request Latency:**\n- Time to handle a request\n- Distribution of response times\n\n2. **Error Rate:**\n- Failed requests/total requests\n- Error budget consumption\n\n3. **System Throughput:**\n- Requests per second\n- Transactions per second",
    "tags": [
      "sre",
      "reliability"
    ],
    "difficulty": "intermediate",
    "channel": "sre",
    "subChannel": "reliability"
  },
  {
    "id": "gh-62",
    "question": "What is Error Budget?",
    "answer": "An Error Budget is the maximum amount of time that a technical system can fail without contractual consequences. It's the difference between the SLO t...",
    "explanation": "An Error Budget is the maximum amount of time that a technical system can fail without contractual consequences. It's the difference between the SLO target and 100% reliability.\n\nExample calculation:\n```\nSLO Target: 99.9% uptime\nError Budget: 100% - 99.9% = 0.1%\nMonthly Error Budget: 43.2 minutes (0.1% of 30 days)\n```\n\nKey concepts:\n1. **Budget Calculation:**\n- Based on SLO targets\n- Measured over time windows\n- Reset periodically\n\n2. **Budget Usage:**\n- Track incidents\n- Monitor consumption\n- Alert on budget burn",
    "tags": [
      "sre",
      "reliability"
    ],
    "difficulty": "beginner",
    "channel": "sre",
    "subChannel": "reliability"
  },
  {
    "id": "gh-63",
    "question": "What is Toil in SRE?",
    "answer": "Toil is the kind of work tied to running a production service that tends to be manual, repetitive, automatable, tactical, devoid of enduring value, an...",
    "explanation": "Toil is the kind of work tied to running a production service that tends to be manual, repetitive, automatable, tactical, devoid of enduring value, and that scales linearly as a service grows.\n\nCharacteristics of toil:\n1. **Manual work:**\n- No automation\n- Human intervention required\n- Repetitive tasks\n\n2. **Impact:**\n- Reduces time for project work\n- Increases operational overhead\n- Affects team morale\n\n3. **Solutions:**\n\nAutomation:\n- Script repetitive tasks\n- Implement self-service tools\n- Create automated workflows\n\nProcess Improvement:\n- Identify toil sources\n- Set toil budgets\n- Track toil metrics\n\nEngineering Solutions:\n- Design for automation\n- Build self-healing systems\n- Implement proper monitoring",
    "tags": [
      "sre",
      "reliability"
    ],
    "difficulty": "beginner",
    "channel": "sre",
    "subChannel": "reliability"
  },
  {
    "id": "gh-64",
    "question": "What are DevOps Metrics?",
    "answer": "DevOps metrics are measurements used to evaluate the performance and efficiency of DevOps practices and processes.",
    "explanation": "DevOps metrics are measurements used to evaluate the performance and efficiency of DevOps practices and processes.\n\nKey categories:\n1. **Velocity Metrics:**\n- Deployment frequency\n- Lead time for changes\n- Time to market\n\n2. **Quality Metrics:**\n- Change failure rate\n- Bug detection rate\n- Test coverage\n\n3. **Operational Metrics:**\n```yaml\nPerformance:\n- Application response time\n- Error rates\n- Resource utilization\n\nReliability:\n- System uptime\n- MTTR\n- MTBF\n```",
    "tags": [
      "metrics",
      "kpi"
    ],
    "difficulty": "intermediate",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-65",
    "question": "What is Mean Time to Recovery (MTTR)?",
    "answer": "MTTR is the average time it takes to recover from a system failure or incident.",
    "explanation": "MTTR is the average time it takes to recover from a system failure or incident.\n\nCalculation:\n```\nMTTR = Total Recovery Time / Number of Incidents\n```\n\nComponents of MTTR:\n1. **Detection Time:**\n- Time to identify the issue\n- Monitoring alerts\n\n2. **Response Time:**\n- Time to begin addressing the issue\n- Team mobilization\n\n3. **Resolution Time:**\n- Time to fix the issue\n- System restoration",
    "tags": [
      "metrics",
      "kpi"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-66",
    "question": "What is Serverless Computing?",
    "answer": "Serverless computing is a cloud computing execution model where the cloud provider manages the infrastructure and automatically allocates resources ba...",
    "explanation": "Serverless computing is a cloud computing execution model where the cloud provider manages the infrastructure and automatically allocates resources based on demand.\n\nKey characteristics:\n1. **No Server Management:**\n- Zero infrastructure maintenance\n- Automatic scaling\n- Pay-per-use billing\n\n2. **Event-Driven:**\n- Function triggers\n- Automatic execution\n- Stateless operations\n\nExample AWS Lambda function:\n```javascript\nexports.handler = async (event) => {\ntry {\nconst result = await processEvent(event);\nreturn {\nstatusCode: 200,\nbody: JSON.stringify(result)\n};\n} catch (error) {\nreturn {\nstatusCode: 500,\nbody: JSON.stringify({ error: error.message })\n};\n}\n};\n```",
    "tags": [
      "serverless",
      "lambda"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "aws"
  },
  {
    "id": "gh-67",
    "question": "What is Database DevOps?",
    "answer": "Database DevOps is the practice of applying DevOps principles to database development and management.",
    "explanation": "Database DevOps is the practice of applying DevOps principles to database development and management.\n\nKey practices:\n1. **Version Control:**\n- Schema versioning\n- Code-first approach\n- Migration scripts\n\n2. **Automation:**\n```yaml\nContinuous Integration:\n- Automated testing\n- Schema validation\n- Data consistency checks\n\nContinuous Delivery:\n- Automated deployments\n- Rollback procedures\n- Data synchronization\n```",
    "tags": [
      "db",
      "devops"
    ],
    "difficulty": "beginner",
    "channel": "database",
    "subChannel": "fundamentals"
  },
  {
    "id": "gh-68",
    "question": "What is Network Security in DevOps?",
    "answer": "Network Security in DevOps involves implementing security measures throughout the development and deployment pipeline to protect applications and infr...",
    "explanation": "Network Security in DevOps involves implementing security measures throughout the development and deployment pipeline to protect applications and infrastructure.\n\nKey components:\n1. **Infrastructure Security:**\n- Firewalls\n- VPNs\n- Network segmentation\n\n2. **Application Security:**\n- TLS encryption\n- API security\n- Authentication/Authorization\n\nExample of security group configuration:\n```yaml\nSecurityGroup:\nType: AWS::EC2::SecurityGroup\nProperties:\nGroupDescription: Web tier security group\nSecurityGroupIngress:\n- IpProtocol: tcp\nFromPort: 443\nToPort: 443\nCidrIp: 0.0.0.0/0\n- IpProtocol: tcp\nFromPort: 80\nToPort: 80\nCidrIp: 0.0.0.0/0\n```",
    "tags": [
      "security",
      "network"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "networking"
  },
  {
    "id": "gh-69",
    "question": "What is Zero Trust Security?",
    "answer": "Zero Trust Security is a security model that requires strict identity verification for every person and device trying to access resources in a private...",
    "explanation": "Zero Trust Security is a security model that requires strict identity verification for every person and device trying to access resources in a private network.\n\nPrinciples:\n1. **Never Trust, Always Verify:**\n- Identity-based access\n- Continuous verification\n- Least privilege access\n\n2. **Implementation:**\n```yaml\nAccess Control:\n- Multi-factor authentication\n- Identity and access management\n- Device verification\n\nNetwork Security:\n- Micro-segmentation\n- Network isolation\n- Encrypted communications\n```",
    "tags": [
      "security",
      "network"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "networking"
  },
  {
    "id": "gh-70",
    "question": "What is SSL/TLS?",
    "answer": "SSL/TLS is a cryptographic protocol used to secure communications between a client and a server.",
    "explanation": "SSL/TLS is a cryptographic protocol used to secure communications between a client and a server.\n\nKey concepts:\n1. **Encryption:**\n- Data is encrypted before transmission\n- Data is decrypted after transmission\n\n2. **Authentication:**\n- Verifies the identity of the communicating parties\n\nExample of SSL/TLS configuration:\n```yaml\nsecurity:\nssl:\nenabled: true\nprotocol: TLSv1.2\nciphers:\n- ECDHE-RSA-AES256-GCM-SHA384\n- ECDHE-RSA-AES128-GCM-SHA256\n```",
    "tags": [
      "security",
      "network"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "networking"
  },
  {
    "id": "gh-71",
    "question": "What is a Web Application Firewall (WAF)?",
    "answer": "A Web Application Firewall (WAF) is a security device that monitors incoming traffic to a web application and blocks malicious traffic.",
    "explanation": "A Web Application Firewall (WAF) is a security device that monitors incoming traffic to a web application and blocks malicious traffic.\n\nKey features:\n1. **Filtering:**\n- Filters out malicious traffic\n- Allows legitimate traffic\n\n2. **Authentication:**\n- Verifies the identity of the communicating parties\n\nExample of WAF configuration:\n```yaml\nsecurity:\nwaf:\nenabled: true\nrules:\n- rule1\n- rule2\n```",
    "tags": [
      "security",
      "network"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "networking"
  },
  {
    "id": "gh-72",
    "question": "What is Network Segmentation?",
    "answer": "Network Segmentation is the practice of dividing a network into smaller, more manageable segments to improve security and performance.",
    "explanation": "Network Segmentation is the practice of dividing a network into smaller, more manageable segments to improve security and performance.\n\nKey concepts:\n1. **Segmentation:**\n- Divides the network into smaller segments\n- Each segment is isolated from other segments\n\n2. **Security:**\n- Prevents unauthorized access to sensitive data\n- Improves network performance\n\nExample of network segmentation configuration:\n```yaml\nsecurity:\nnetwork:\nsegmentation:\nenabled: true\nrules:\n- rule1\n- rule2\n```",
    "tags": [
      "security",
      "network"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "networking"
  },
  {
    "id": "gh-73",
    "question": "What is Incident Management?",
    "answer": "Incident Management is the process of responding to and resolving IT service disruptions.",
    "explanation": "Incident Management is the process of responding to and resolving IT service disruptions.\n\nKey components:\n1. **Detection:**\n- Monitoring alerts\n- User reports\n- Automated detection\n\n2. **Response:**\n```yaml\nInitial Response:\n- Acknowledge incident\n- Assess severity\n- Notify stakeholders\n\nResolution:\n- Investigate root cause\n- Apply fix\n- Verify solution\n```",
    "tags": [
      "incident",
      "on-call"
    ],
    "difficulty": "beginner",
    "channel": "sre",
    "subChannel": "incident-management",
    "diagram": "\ngraph LR\n    Detect[Detect] --> Respond[Respond]\n    Respond --> Resolve[Resolve]\n    Resolve --> Review[Post-Mortem]\n"
  },
  {
    "id": "gh-74",
    "question": "What is DevOps Culture?",
    "answer": "DevOps Culture is a set of practices and values that promotes collaboration between Development and Operations teams.",
    "explanation": "DevOps Culture is a set of practices and values that promotes collaboration between Development and Operations teams.\n\nKey principles:\n1. **Collaboration:**\n- Shared responsibility\n- Cross-functional teams\n- Open communication\n\n2. **Continuous Improvement:**\n- Learning from failures\n- Experimentation\n- Feedback loops\n\n3. **Automation:**\n- Automate repetitive tasks\n- Infrastructure as Code\n- Continuous Integration/Delivery",
    "tags": [
      "culture",
      "soft-skills"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-75",
    "question": "What are DevOps Best Practices?",
    "answer": "DevOps best practices are proven methods that enhance software development and delivery.",
    "explanation": "DevOps best practices are proven methods that enhance software development and delivery.\n\nKey practices:\n```yaml\nTechnical Practices:\n- Infrastructure as Code\n- Continuous Integration\n- Automated Testing\n- Continuous Deployment\n- Monitoring and Logging\n\nCultural Practices:\n- Shared Responsibility\n- Blameless Post-mortems\n- Knowledge Sharing\n- Continuous Learning\n- Cross-functional Teams\n\nProcess Practices:\n- Agile Methodology\n- Version Control\n- Configuration Management\n- Release Management\n- Incident Management\n```",
    "tags": [
      "culture",
      "soft-skills"
    ],
    "difficulty": "intermediate",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-76",
    "question": "What is Infrastructure Monitoring?",
    "answer": "Infrastructure Monitoring is the process of collecting and analyzing data from IT infrastructure components to ensure optimal performance and availabi...",
    "explanation": "Infrastructure Monitoring is the process of collecting and analyzing data from IT infrastructure components to ensure optimal performance and availability.\n\nKey components:\n1. **Metrics Collection:**\n- System metrics\n- Network metrics\n- Application metrics\n\n2. **Analysis:**\n```yaml\nMonitoring Areas:\n- Resource utilization\n- Performance metrics\n- Availability\n- Error rates\n- Response times\n```",
    "tags": [
      "monitoring",
      "infra"
    ],
    "difficulty": "beginner",
    "channel": "sre",
    "subChannel": "observability"
  },
  {
    "id": "gh-77",
    "question": "What are Monitoring Tools?",
    "answer": "Common monitoring tools used in DevOps:",
    "explanation": "Common monitoring tools used in DevOps:\n\n1. **Infrastructure Monitoring:**\n- Prometheus\n- Nagios\n- Zabbix\n- Datadog\n\n2. **Application Monitoring:**\n```yaml\nTools:\n- New Relic\n- AppDynamics\n- Dynatrace\nFeatures:\n- Transaction tracing\n- Error tracking\n- Performance analytics\n```",
    "tags": [
      "monitoring",
      "infra"
    ],
    "difficulty": "intermediate",
    "channel": "sre",
    "subChannel": "observability"
  },
  {
    "id": "gh-78",
    "question": "What are Monitoring Best Practices?",
    "answer": "Monitoring Best Practices are proven methods that enhance the effectiveness of monitoring tools and processes.",
    "explanation": "Monitoring Best Practices are proven methods that enhance the effectiveness of monitoring tools and processes.\n\nKey practices:\n```yaml\nTechnical Practices:\n- Infrastructure as Code\n- Continuous Integration\n- Automated Testing\n- Continuous Deployment\n- Monitoring and Logging\n\nCultural Practices:\n- Shared Responsibility\n- Blameless Post-mortems\n- Knowledge Sharing\n- Continuous Learning\n- Cross-functional Teams\n\nProcess Practices:\n- Agile Methodology\n- Version Control\n- Configuration Management\n- Release Management\n- Incident Management\n```",
    "tags": [
      "monitoring",
      "infra"
    ],
    "difficulty": "intermediate",
    "channel": "sre",
    "subChannel": "observability"
  },
  {
    "id": "gh-79",
    "question": "What is Application Performance Monitoring?",
    "answer": "Application Performance Monitoring (APM) is the practice of collecting and analyzing data about the performance and stability of applications to impro...",
    "explanation": "Application Performance Monitoring (APM) is the practice of collecting and analyzing data about the performance and stability of applications to improve their reliability and responsiveness.\n\nKey components:\n1. **Metrics Collection:**\n- Application metrics\n- Transaction tracing\n- Error tracking\n- Performance analytics\n\n2. **Analysis:**\n```yaml\nMonitoring Areas:\n- Application response times\n- Error rates\n- Resource utilization\n- Scalability\n- Reliability\n```",
    "tags": [
      "monitoring",
      "infra"
    ],
    "difficulty": "beginner",
    "channel": "sre",
    "subChannel": "observability"
  },
  {
    "id": "gh-80",
    "question": "What is Log Management?",
    "answer": "Log Management is the practice of collecting, analyzing, and managing log data to help diagnose and troubleshoot issues.",
    "explanation": "Log Management is the practice of collecting, analyzing, and managing log data to help diagnose and troubleshoot issues.\n\nKey components:\n1. **Log Collection:**\n- Collecting log data from various sources\n- Centralized logging infrastructure\n\n2. **Log Analysis:**\n- Log aggregation\n- Security analytics\n- Application performance monitoring\n- Website search\n- Business analytics\n\n3. **Log Visualization:**\n- Dashboard creation\n- Alerting\n- Visualization",
    "tags": [
      "monitoring",
      "infra"
    ],
    "difficulty": "beginner",
    "channel": "sre",
    "subChannel": "observability"
  },
  {
    "id": "gh-81",
    "question": "What is Cloud Migration?",
    "answer": "Cloud Migration is the process of moving digital assets — applications, data, IT resources — from on-premises infrastructure to cloud infrastructure.",
    "explanation": "Cloud Migration is the process of moving digital assets — applications, data, IT resources — from on-premises infrastructure to cloud infrastructure.\n\nKey aspects:\n1. **Planning:**\n- Assessment\n- Strategy development\n- Resource planning\n\n2. **Execution:**\n```yaml\nMigration Steps:\n- Data migration\n- Application migration\n- Testing\n- Validation\n- Cutover\n```",
    "tags": [
      "migration",
      "cloud"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-82",
    "question": "What are Cloud Migration Strategies?",
    "answer": "Common cloud migration strategies (6 R's):",
    "explanation": "Common cloud migration strategies (6 R's):\n\n1. **Rehosting (Lift and Shift):**\n- Moving applications without changes\n- Quickest migration method\n- Minimal optimization\n\n2. **Replatforming (Lift, Tinker and Shift):**\n- Minor optimizations\n- Cloud-specific improvements\n- Maintaining core architecture\n\n3. **Refactoring/Re-architecting:**\n```yaml\nBenefits:\n- Better cloud-native features\n- Improved scalability\n- Enhanced performance\nChallenges:\n- More time-consuming\n- Higher initial costs\n- Required expertise\n```",
    "tags": [
      "migration",
      "cloud"
    ],
    "difficulty": "intermediate",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-83",
    "question": "What is Cloud Assessment?",
    "answer": "Cloud Assessment is the process of evaluating the suitability of cloud services for a specific use case or workload.",
    "explanation": "Cloud Assessment is the process of evaluating the suitability of cloud services for a specific use case or workload.\n\nKey components:\n1. **Assessment Criteria:**\n- Cloud service capabilities\n- Cost and pricing\n- Security and compliance\n- Performance and scalability\n- Disaster recovery and high availability\n\n2. **Assessment Methodology:**\n- Cloud service comparison\n- Risk assessment\n- Cost-benefit analysis",
    "tags": [
      "migration",
      "cloud"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-84",
    "question": "What is Application Modernization?",
    "answer": "Application Modernization is the process of transforming existing applications to leverage cloud-native features and capabilities.",
    "explanation": "Application Modernization is the process of transforming existing applications to leverage cloud-native features and capabilities.\n\nKey components:\n1. **Application Analysis:**\n- Current application state\n- Application architecture\n- Technology stack\n\n2. **Modernization Strategy:**\n- Cloud-native architecture\n- Microservices\n- Containerization\n- Serverless computing\n\n3. **Migration:**\n- Data migration\n- Application migration\n- Testing\n- Validation\n- Cutover",
    "tags": [
      "migration",
      "cloud"
    ],
    "difficulty": "beginner",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-85",
    "question": "What are Cloud Migration Tools?",
    "answer": "Cloud Migration Tools are software tools that help automate the migration of applications and data to cloud platforms.",
    "explanation": "Cloud Migration Tools are software tools that help automate the migration of applications and data to cloud platforms.\n\nKey components:\n1. **Data Migration Tools:**\n- Database migration tools\n- Application migration tools\n- Data synchronization tools\n\n2. **Application Migration Tools:**\n- Application packaging tools\n- Application containerization tools\n- Application serverless tools\n\n3. **Migration Orchestration Tools:**\n- Workflow automation tools\n- Service coordination tools\n- Resource scheduling tools",
    "tags": [
      "migration",
      "cloud"
    ],
    "difficulty": "intermediate",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-86",
    "question": "What is Platform Engineering?",
    "answer": "Platform Engineering is the discipline of designing, building, and maintaining an Internal Developer Platform (IDP). An IDP provides a self-service la...",
    "explanation": "Platform Engineering is the discipline of designing, building, and maintaining an Internal Developer Platform (IDP). An IDP provides a self-service layer that enables development teams to autonomously manage the lifecycle of their applications without needing deep expertise in underlying infrastructure, CI/CD, or operational tooling. The goal is to enhance developer experience, productivity, and velocity while ensuring standardization, compliance, and operational excellence.\n\n**Key Aspects of Platform Engineering:**\n1.  **Internal Developer Platform (IDP):** The core product created by a platform engineering team. It typically includes:\n*   **Self-Service Capabilities:** Developers can provision infrastructure, set up CI/CD pipelines, deploy applications, and access monitoring/logging tools through a user-friendly interface or API.\n*   **Golden Paths:** Pre-configured, validated workflows and toolchains for common tasks (e.g., creating a new microservice, deploying to Kubernetes).\n*   **Abstraction:** Hides the complexity of underlying tools and infrastructure.\n*   **Standardization:** Enforces best practices, security policies, and compliance across teams.\n2.  **Developer Experience (DevEx):** A primary focus is to reduce cognitive load on developers and streamline their workflows.\n3.  **Automation:** Automating as much of the application lifecycle as possible.\n4.  **Collaboration:** Platform teams work closely with development teams to understand their needs and gather feedback.\n5.  **Product Mindset:** Treating the IDP as a product with users (developers), requiring continuous iteration and improvement.\n\n**Benefits:**\n*   **Increased Developer Velocity & Productivity:** Developers spend less time on infrastructure and operational tasks.\n*   **Improved Reliability & Stability:** Standardized and automated processes reduce human error.\n*   **Enhanced Security & Compliance:** Policies are embedded into the platform.\n*   **Faster Time to Market:** Streamlined workflows accelerate the delivery of new features.\n*   **Scalability:** Enables organizations to scale their development efforts more effectively.\n\n**Example IDP Components:**\n```mermaid\ngraph TD\nsubgraph IDP [Internal Developer Platform]\nA[Developer Portal/CLI] --> B{Self-Service APIs}\nB --> C[Service Catalog]\nB --> D[CI/CD Automation]\nB --> E[Infrastructure Provisioning]\nB --> F[Monitoring & Observability Tools]\nB --> G[Security & Compliance Policies]\nend\nDev[Developer] --> A\nD --> H[Deployment Targets e.g., Kubernetes]\nE --> I[Cloud Providers/On-prem Infra]\nF --> J[Logging & Metrics Systems]\nG --> D\nG --> E\n```",
    "tags": [
      "advanced",
      "cloud"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-87",
    "question": "What is FinOps?",
    "answer": "FinOps (Cloud Financial Operations) is an evolving cloud financial management discipline and cultural practice that enables organizations to get maxim...",
    "explanation": "FinOps (Cloud Financial Operations) is an evolving cloud financial management discipline and cultural practice that enables organizations to get maximum business value by helping engineering, finance, technology, and business teams to collaborate on data-driven spending decisions. It focuses on understanding cloud costs, optimizing spending, and implementing governance.\n\n**Core Principles of FinOps:**\n1.  **Collaboration:** Teams need to collaborate. Engineering, finance, product, and leadership must work together.\n2.  **Ownership:** Decisions are driven by the business value of cloud. Teams take ownership of their cloud usage, cost, and efficiency.\n3.  **Centralized Team:** A centralized FinOps team (often a CCoE - Cloud Center of Excellence subset) drives governance and best practices.\n4.  **Reporting & Visibility:** Timely, accessible, and accurate reports are crucial for understanding cloud spend.\n5.  **Cost Optimization:** Teams are empowered to optimize for cost, balancing performance, quality, and speed.\n6.  **Predictable Economics:** Strive for predictable cloud economics through forecasting, budgeting, and managing variances.\n\n**Phases of FinOps Lifecycle:**\n1.  **Inform:** Provide visibility into cloud spending through allocation, tagging, showback, and chargeback.\n*   Tools: Cloud provider cost management tools (AWS Cost Explorer, Azure Cost Management, GCP Billing), third-party tools (Cloudability, Apptio Cloudability, Flexera One).\n2.  **Optimize:** Implement cost-saving measures.\n*   Examples: Right-sizing instances, using reserved instances/savings plans, identifying and terminating idle resources, implementing auto-scaling, choosing appropriate storage tiers.\n3.  **Operate:** Define and enforce policies, establish budgets, and continuously monitor and improve.\n*   Examples: Setting budget alerts, automating cost control measures, performing regular cost reviews.\n\n**Benefits of FinOps:**\n*   Improved financial control and predictability of cloud costs.\n*   Increased ROI from cloud investments.\n*   Better alignment between cloud spending and business objectives.\n*   Enhanced collaboration between finance and engineering teams.\n*   Data-driven decision-making for cloud resource utilization.",
    "tags": [
      "advanced",
      "cloud"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-88",
    "question": "What is Policy as Code?",
    "answer": "Policy as Code (PaC) is the practice of defining, managing, and automating policies using code and version control systems, similar to Infrastructure ...",
    "explanation": "Policy as Code (PaC) is the practice of defining, managing, and automating policies using code and version control systems, similar to Infrastructure as Code (IaC). Instead of manually configuring policies through UIs or disparate systems, PaC allows organizations to express policies in a high-level, human-readable language, store them in a Git repository, and apply them automatically throughout the development lifecycle and in production environments.\n\n**Key Concepts:**\n1.  **Policy Definition:** Policies are written in a declarative language (e.g., Rego for Open Policy Agent, Sentinel for HashiCorp tools).\n2.  **Version Control:** Policies are stored in Git, enabling versioning, auditing, and collaboration.\n3.  **Automation:** Policies are automatically enforced at various stages (e.g., CI/CD pipeline, infrastructure provisioning, Kubernetes admission control).\n4.  **Shift Left:** Enables early detection and prevention of policy violations during development.\n5.  **Auditability:** Provides a clear audit trail of policy changes and enforcement.\n\n**Use Cases:**\n*   **Security:** Enforcing security best practices, such as disallowing public S3 buckets or ensuring encryption.\n*   **Compliance:** Meeting regulatory requirements (e.g., GDPR, HIPAA) by codifying compliance rules.\n*   **Cost Management:** Preventing the creation of overly expensive resources.\n*   **Operational Consistency:** Ensuring standardized configurations across environments.\n*   **Kubernetes Governance:** Controlling what can be deployed to a Kubernetes cluster (e.g., required labels, resource limits, image sources).\n\n**Popular Tools:**\n*   **Open Policy Agent (OPA):** An open-source, general-purpose policy engine.\n*   **HashiCorp Sentinel:** A policy as code framework embedded in HashiCorp enterprise products (Terraform, Vault, Nomad, Consul).\n*   **Kyverno:** A policy engine designed specifically for Kubernetes.\n*   Cloud provider specific tools (e.g., AWS Config Rules, Azure Policy).\n\n**Example (Conceptual OPA/Rego):**\n```rego\npackage main\n\n# Deny deployments if an image is not from a trusted registry\ndeny[msg] {\ninput.kind == \"Deployment\"\nimage_name := input.spec.template.spec.containers[_].image\nnot startswith(image_name, \"trusted.registry.io/\")\nmsg := sprintf(\"Image '%v' is not from a trusted registry\", [image_name])\n}\n```",
    "tags": [
      "advanced",
      "cloud"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-89",
    "question": "What is Chaos Engineering?",
    "answer": "Chaos Engineering is the discipline of experimenting on a distributed system in production in order to build confidence in the system's capability to ...",
    "explanation": "Chaos Engineering is the discipline of experimenting on a distributed system in production in order to build confidence in the system's capability to withstand turbulent and unexpected conditions. It's a proactive approach to identifying weaknesses by intentionally injecting failures and observing the system's response.\n\n**Principles of Chaos Engineering:**\n1.  **Build a Hypothesis around Steady State Behavior:** Define what normal system behavior looks like (e.g., key performance indicators, SLIs).\n2.  **Vary Real-world Events:** Simulate failures that can occur in production (e.g., server crashes, network latency, disk failures, dependency unavailability).\n3.  **Run Experiments in Production (or a Production-like Environment):** Testing in production is crucial as it's the only way to understand how the system behaves under real-world load and conditions. Start with staging environments if needed.\n4.  **Automate Experiments to Run Continuously:** Integrate chaos experiments into CI/CD pipelines or run them regularly to ensure ongoing resilience.\n5.  **Minimize Blast Radius:** Start with small, controlled experiments and gradually increase the scope to limit potential negative impact.\n\n**Process of a Chaos Experiment:**\n1.  **Define Steady State:** Identify measurable metrics that indicate normal system behavior.\n2.  **Hypothesize:** Formulate a hypothesis about how the system will respond to a specific failure. (e.g., \"If we introduce 100ms latency to the database, the API response time will increase by no more than 150ms, and there will be no errors.\")\n3.  **Design Experiment:** Determine the type of failure to inject, the scope, and the duration.\n4.  **Execute Experiment:** Inject the failure.\n5.  **Measure and Analyze:** Observe the system's behavior and compare it to the hypothesis.\n6.  **Learn and Improve:** If the system didn't behave as expected, identify the weakness and implement fixes. If it did, increase confidence or expand the experiment.\n\n**Benefits:**\n*   Uncovers hidden issues and weaknesses before they cause major outages.\n*   Improves system resilience and fault tolerance.\n*   Increases confidence in the system's ability to handle failures.\n*   Reduces incident response time and mean time to recovery (MTTR).\n*   Validates monitoring, alerting, and auto-remediation mechanisms.\n\n**Common Tools:**\n*   **Chaos Monkey (Netflix):** Randomly terminates virtual machine instances.\n*   **Gremlin:** A \"Failure-as-a-Service\" platform offering various chaos experiments.\n*   **Chaos Mesh:** A cloud-native chaos engineering platform for Kubernetes.\n*   **AWS Fault Injection Simulator (FIS):** A managed service for running fault injection experiments on AWS.\n*   **LitmusChaos:** An open-source chaos engineering framework for Kubernetes.",
    "tags": [
      "advanced",
      "cloud"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-90",
    "question": "What is Blue/Green Deployment?",
    "answer": "Blue/Green Deployment is a continuous deployment strategy that aims to minimize downtime and risk by maintaining two identical production environments...",
    "explanation": "Blue/Green Deployment is a continuous deployment strategy that aims to minimize downtime and risk by maintaining two identical production environments, referred to as \"Blue\" and \"Green.\" Only one environment serves live production traffic at any given time.\n\n**How it Works:**\n1.  **Live Environment (Blue):** The current production environment handling all user traffic.\n2.  **Staging/New Environment (Green):** An identical environment where the new version of the application is deployed and thoroughly tested.\n3.  **Traffic Switch:** Once the Green environment is verified, a router or load balancer redirects all incoming traffic from Blue to Green. The Green environment now becomes the live production environment.\n4.  **Rollback:** If issues are detected in the Green environment after the switch, traffic can be quickly routed back to the Blue environment (which still runs the old, stable version).\n5.  **Promotion:** After a period of monitoring the new Green environment, the Blue environment can be updated to the new version to become the staging environment for the next release, or it can be decommissioned.\n\n```mermaid\ngraph TD\n    LB[Load Balancer] -->|Switch| Blue[\"Blue Env<br/>v1\"]\n    LB -->|Switch| Green[\"Green Env<br/>v2\"]\n    Blue -.->|Rollback| LB\n    style Blue fill:#3b82f6,stroke:#fff\n    style Green fill:#22c55e,stroke:#fff\n```\n\n**Benefits:**\n*   **Near-Zero Downtime:** Traffic is switched instantaneously.\n*   **Reduced Risk:** The new version is fully tested in an identical production environment before going live.\n*   **Rapid Rollback:** Reverting to the previous version is as simple as switching traffic back.\n*   **Simplified Release Process:** The process is straightforward and well-understood.\n\n**Considerations:**\n*   **Resource Costs:** Requires maintaining two full production environments, which can be expensive.\n*   **Database Compatibility:** Managing database schema changes and data synchronization between Blue and Green environments can be complex. Strategies like using backward-compatible changes or separate database instances are often employed.\n*   **Stateful Applications:** Handling user sessions and other stateful components requires careful planning during the switch.\n*   **Long-running Transactions:** Can be affected during the switchover.",
    "tags": [
      "advanced",
      "cloud"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-91",
    "question": "What is Feature Flagging?",
    "answer": "Feature Flagging (also known as Feature Toggles or Feature Switches) is a software development technique that allows teams to modify system behavior w...",
    "explanation": "Feature Flagging (also known as Feature Toggles or Feature Switches) is a software development technique that allows teams to modify system behavior without changing code and redeploying. It involves wrapping new features in conditional logic (the \"flag\") that can be toggled on or off in a running application, often via a configuration service.\n\n**Core Concepts:**\n1.  **Decoupling Deployment from Release:** Code can be deployed to production environments with new features \"turned off\" (hidden behind a flag). The feature is then \"released\" (turned on) for users at a later time, independently of the deployment.\n2.  **Conditional Logic:** Code paths for the new feature are executed only if the corresponding flag is enabled.\n3.  **Configuration Service:** A central service or configuration file is often used to manage the state of feature flags, allowing dynamic updates without code changes.\n\n**Types of Feature Flags:**\n*   **Release Toggles:** Used to enable or disable features for all users, often for canary releases or to quickly disable a problematic feature.\n*   **Experiment Toggles (A/B Testing):** Used to show different versions of a feature to different segments of users to measure impact.\n*   **Ops Toggles:** Used to control operational aspects of the system, like enabling detailed logging or switching to a backup system during an incident.\n*   **Permission Toggles:** Used to control access to features for specific user groups (e.g., beta testers, premium users).\n\n**Benefits:**\n*   **Reduced Risk:** New features can be tested in production with a limited audience (canary release) or turned off quickly if issues arise (\"kill switch\").\n*   **Continuous Delivery/Trunk-Based Development:** Allows developers to merge code to the main branch more frequently, even if features are incomplete, by keeping them hidden behind flags.\n*   **A/B Testing and Experimentation:** Facilitates testing different feature variations with real users.\n*   **Gradual Rollouts:** Features can be rolled out to progressively larger groups of users.\n*   **Operational Control:** Provides levers to manage system behavior in production.\n*   **Faster Feedback Loops:** Get feedback on features from a subset of users before a full release.\n\n**Considerations:**\n*   **Flag Management Complexity:** A large number of flags can become difficult to manage. Requires a clear strategy for naming, organizing, and retiring flags.\n*   **Testing Overhead:** Need to test code paths with flags both on and off.\n*   **Technical Debt:** Old flags that are no longer needed should be removed to avoid cluttering the codebase.\n*   **Performance:** Checking flag states might add a small overhead, though usually negligible.",
    "tags": [
      "advanced",
      "cloud"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-92",
    "question": "What is a Service Catalog?",
    "answer": "A Service Catalog is a centralized, curated list of IT services that an organization offers to its employees or customers. In the context of DevOps an...",
    "explanation": "A Service Catalog is a centralized, curated list of IT services that an organization offers to its employees or customers. In the context of DevOps and Platform Engineering, it's a key component of an Internal Developer Platform (IDP), providing developers with a self-service portal to discover, request, and provision standardized resources, tools, and environments.\n\n**Key Characteristics & Purpose:**\n1.  **Discoverability:** Provides a single place for users (typically developers) to find available services (e.g., databases, CI/CD pipeline templates, Kubernetes clusters, monitoring dashboards).\n2.  **Standardization:** Offers pre-configured, vetted, and compliant versions of services, ensuring consistency and adherence to organizational best practices.\n3.  **Self-Service:** Enables users to request and provision services on-demand without manual intervention from IT operations or platform teams.\n4.  **Automation:** Behind the scenes, service requests from the catalog trigger automated provisioning workflows.\n5.  **Lifecycle Management:** Can include information about service versions, support, and decommissioning.\n6.  **Transparency:** Often includes details about service SLAs, costs, and usage guidelines.\n\n**Benefits:**\n*   **Increased Developer Productivity:** Developers can quickly access the resources they need without waiting for manual fulfillment.\n*   **Improved Governance & Compliance:** Ensures that only approved and compliant services are used.\n*   **Reduced Operational Overhead:** Automates service provisioning, freeing up operations teams.\n*   **Enhanced Consistency:** Standardized services reduce configuration drift and compatibility issues.\n*   **Cost Control:** Can provide visibility into service costs and help manage cloud spend by offering optimized options.\n*   **Better User Experience:** Simplifies the process of obtaining IT resources.\n\n**Examples of Services in a Developer-Focused Service Catalog:**\n*   New Microservice Template (with CI/CD pipeline)\n*   Managed PostgreSQL Database (various sizes)\n*   Kubernetes Namespace with pre-defined quotas\n*   On-demand Test Environment\n*   Access to a specific logging or monitoring tool\n*   Vulnerability Scanning Service\n\n**Tools:**\n*   **Backstage (CNCF):** An open platform for building developer portals, often used to create service catalogs.\n*   **Port:** A developer portal platform.\n*   IT Service Management (ITSM) tools (e.g., ServiceNow, Jira Service Management) can also be adapted.\n*   Custom-built portals.",
    "tags": [
      "advanced",
      "cloud"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-93",
    "question": "What is a Service Level Agreement (SLA)?",
    "answer": "A Service Level Agreement (SLA) is a formal, externally-facing contract or commitment between a service provider and its customers (or users). It defi...",
    "explanation": "A Service Level Agreement (SLA) is a formal, externally-facing contract or commitment between a service provider and its customers (or users). It defines the specific level of service that will be provided, including metrics, responsibilities, and remedies or penalties if the agreed-upon service levels are not met.\n\n**Key Components of an SLA:**\n1.  **Service Description:** Clearly defines the service being provided.\n2.  **Parties Involved:** Identifies the service provider and the customer.\n3.  **Agreement Period:** Specifies the duration for which the SLA is valid.\n4.  **Service Availability:** Defines the expected uptime or availability of the service (e.g., 99.9% uptime per month).\n5.  **Performance Metrics:** Specifies key performance indicators (KPIs) and their targets (e.g., API response time, data processing throughput).\n6.  **Responsibilities:** Outlines the duties of both the service provider and the customer.\n7.  **Support and Escalation Procedures:** Details how support will be provided, response times for issues, and how problems will be escalated.\n8.  **Exclusions:** Lists conditions or events that are not covered by the SLA (e.g., scheduled maintenance, force majeure).\n9.  **Remedies or Penalties (Service Credits):** Describes the compensation or actions (e.g., service credits, discounts) if the provider fails to meet the SLA terms.\n10. **Reporting and Monitoring:** Specifies how service performance will be tracked and reported to the customer.\n\n**Purpose in DevOps/SRE:**\n*   **Sets Expectations:** Clearly communicates to users what level of service they can expect.\n*   **Drives Reliability Efforts:** While SLAs are external, they often drive internal targets (SLOs) to ensure commitments are met.\n*   **Accountability:** Provides a basis for holding the service provider accountable for performance.\n*   **Business Alignment:** Helps align IT services with business needs and user expectations.\n\n**Distinction from SLOs and SLIs:**\n*   **SLA (Agreement):** The formal contract with consequences.\n*   **SLO (Objective):** Internal targets set by the service provider to meet or exceed the SLA. SLOs are typically stricter than SLAs to provide a buffer.\n*   **SLI (Indicator):** The actual measurements of service performance (e.g., measured uptime, actual response time). SLIs are used to track performance against SLOs.\n\n**Example SLA Clause for Availability:**\n\"The Service Provider guarantees 99.9% Uptime for the Service during any calendar month. Uptime is defined as the percentage of time the Service is accessible and functioning correctly. If Uptime falls below 99.9% in a given month, the Customer will be eligible for a Service Credit of 5% of their monthly service fee for that month.\"",
    "tags": [
      "advanced",
      "cloud"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-94",
    "question": "What is a Service Level Objective (SLO)?",
    "answer": "A Service Level Objective (SLO) is a specific, measurable, and achievable internal target for a particular aspect of service performance or reliabilit...",
    "explanation": "A Service Level Objective (SLO) is a specific, measurable, and achievable internal target for a particular aspect of service performance or reliability. SLOs are a key component of Site Reliability Engineering (SRE) practices and are used to guide engineering decisions and balance reliability work with feature development.\n\n**Key Characteristics of an SLO:**\n1.  **Service-Specific:** Defined for a particular user-facing service or critical internal system.\n2.  **User-Focused:** Based on what matters to users (e.g., availability, latency, correctness).\n3.  **Measurable:** Quantifiable using specific metrics (SLIs).\n4.  **Target Value:** A specific numerical goal (e.g., 99.9% availability, 99th percentile latency < 200ms).\n5.  **Measurement Window:** The period over which the SLO is evaluated (e.g., rolling 28 days, calendar month).\n6.  **Internal Target:** Used by the team providing the service to manage and improve reliability. SLOs are typically stricter than any corresponding SLAs to provide a safety margin.\n\n**Purpose of SLOs:**\n*   **Data-Driven Decisions:** Provide a quantitative basis for making decisions about reliability, such as when to invest in more resilient infrastructure or when to prioritize bug fixes over new features.\n*   **Error Budgets:** SLOs directly define error budgets. An error budget is the amount of time or number of events a service can fail to meet its SLO without breaching it. For example, an SLO of 99.9% availability over 30 days allows for approximately 43 minutes of downtime (the error budget).\n*   **Balancing Reliability and Innovation:** If the service is consistently meeting its SLOs (i.e., not consuming its error budget), the team can focus more on feature development. If the error budget is being consumed rapidly, the team must prioritize reliability work.\n*   **Shared Understanding:** Creates a common language and understanding of reliability goals across development, operations, and product teams.\n*   **Alerting:** SLO burn rates (how quickly the error budget is being consumed) are often used to trigger alerts, prompting action before the SLO is breached.\n\n**How to Define Good SLOs:**\n1.  **Identify Critical User Journeys (CUJs):** What are the most important things users do with the service?\n2.  **Choose Appropriate SLIs:** Select metrics that accurately reflect the user experience for those CUJs (e.g., request success rate, latency at a specific percentile).\n3.  **Set Achievable Targets:** Consider historical performance, user expectations, and business requirements. Don't aim for 100% if it's not necessary or feasible, as it can be prohibitively expensive and stifle innovation.\n4.  **Document and Communicate:** Ensure SLOs are well-documented and understood by all stakeholders.\n5.  **Iterate:** Regularly review and refine SLOs based on new data and changing requirements.\n\n**Example SLO:**\n*   **Service:** User Login API\n*   **SLI:** Percentage of successful login requests (HTTP 200 responses) over all valid login attempts.\n*   **Target:** 99.95%\n*   **Period:** Measured over a rolling 28-day window.\n*   **Consequence (Internal):** If the error budget (0.05%) is exceeded, new feature development for the login service is paused, and all engineering effort is directed towards reliability improvements until the service is back within SLO.",
    "tags": [
      "advanced",
      "cloud"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-95",
    "question": "What is a Service Level Indicator (SLI)?",
    "answer": "A Service Level Indicator (SLI) is a quantitative measure of some aspect of the level of service provided to users. SLIs are the raw data points or me...",
    "explanation": "A Service Level Indicator (SLI) is a quantitative measure of some aspect of the level of service provided to users. SLIs are the raw data points or metrics used to assess performance against Service Level Objectives (SLOs). They are crucial for objectively understanding how a service is performing from a user's perspective.\n\n**Key Characteristics of an SLI:**\n1.  **Quantitative Measure:** A specific, numerical value derived from system telemetry.\n2.  **User-Centric:** Reflects an aspect of service performance that directly impacts user experience.\n3.  **Directly Measurable:** Can be obtained from monitoring systems, logs, or other data sources.\n4.  **Good Proxy for User Happiness:** A change in the SLI should correlate with a change in user satisfaction.\n5.  **Reliably Measured:** The measurement itself should be accurate and dependable.\n\n**Common Types of SLIs:**\n*   **Availability:** Measures the proportion of time the service is usable or the percentage of successful requests.\n*   *Example:* (Number of successful HTTP requests / Total valid HTTP requests) * 100%.\n*   **Latency:** Measures the time taken to serve a request. Often measured at specific percentiles (e.g., 95th, 99th percentile) to understand typical and worst-case performance.\n*   *Example:* The 99th percentile of API response times for the `/users` endpoint over the last 5 minutes.\n*   **Error Rate:** Measures the proportion of requests that result in errors.\n*   *Example:* (Number of HTTP 5xx responses / Total valid HTTP requests) * 100%.\n*   **Throughput:** Measures the rate at which the system processes requests or data.\n*   *Example:* Requests per second (RPS) handled by the shopping cart service.\n*   **Durability:** Measures the likelihood that data stored in the system will be retained over a long period without corruption.\n*   *Example:* Probability of a stored object remaining intact and accessible after one year.\n*   **Correctness/Quality:** Measures if the service provides the right answer or performs the right action.\n*   *Example:* Percentage of search queries that return relevant results, or proportion of financial transactions processed without data errors.\n\n**How to Choose Good SLIs:**\n1.  **Focus on User Experience:** What aspects of performance or reliability are most important to your users?\n2.  **Keep it Simple:** Choose a small number of meaningful SLIs rather than trying to track everything.\n3.  **Ensure it's Actionable:** The SLI should provide data that can lead to improvements or inform decisions.\n4.  **Distinguish from Raw Metrics:** While SLIs are derived from metrics, they are specifically chosen and often processed (e.g., aggregated, percentiled) to represent service level.\n\n**Relationship with SLOs and SLAs:**\n*   SLIs are the **measurements**.\n*   SLOs are the **targets** for those measurements (e.g., SLI for availability >= 99.9%).\n*   SLAs are the **agreements** with users, often based on achieving certain SLOs, and typically include consequences if not met.\n\n**Example:**\n*   **User Journey:** User uploads a photo.\n*   **Possible SLIs:**\n*   `upload_success_rate`: (Number of successful photo uploads / Total photo upload attempts) * 100%\n*   `upload_latency_p95`: 95th percentile of time taken from initiating upload to confirmation.\n*   **Corresponding SLO for `upload_success_rate` might be:** 99.9% over a 7-day window.",
    "tags": [
      "advanced",
      "cloud"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-96",
    "question": "What is a Runbook?",
    "answer": "A Runbook is a detailed document or a collection of procedures that outlines the steps required to perform a specific operational task or to respond t...",
    "explanation": "A Runbook is a detailed document or a collection of procedures that outlines the steps required to perform a specific operational task or to respond to a particular situation or alert. Traditionally, runbooks were manual guides for system administrators and operators. In modern DevOps and SRE practices, there's a strong emphasis on automating runbooks wherever possible (Runbook Automation).\n\n**Key Characteristics and Purpose of Runbooks:**\n1.  **Standardization:** Provides a consistent and repeatable way to perform routine tasks or respond to incidents, reducing human error.\n2.  **Documentation:** Serves as a knowledge base for operational procedures, especially for less common tasks or for new team members.\n3.  **Efficiency:** Streamlines operations by providing clear, step-by-step instructions, reducing the time taken to resolve issues or complete tasks.\n4.  **Incident Response:** Crucial for quickly addressing known issues, system failures, or alerts by providing pre-defined diagnostic and remediation steps.\n5.  **Training:** Useful for training new operations staff or for cross-training team members.\n6.  **Automation Target:** Well-defined manual runbooks are excellent candidates for automation. Each step in a runbook can potentially be scripted.\n\n**Common Contents of a Runbook:**\n*   **Title/Purpose:** Clear description of the task or situation the runbook addresses.\n*   **Triggers/Symptoms:** When to use this runbook (e.g., specific alert, error message, user report).\n*   **Prerequisites:** Any conditions that must be met or tools/access required before starting.\n*   **Step-by-Step Procedures:** Detailed instructions for diagnosis, remediation, or task execution.\n*   **Verification Steps:** How to confirm the task was successful or the issue is resolved.\n*   **Rollback Procedures:** Steps to revert any changes if the procedure fails or causes unintended consequences.\n*   **Escalation Points:** Who to contact if the runbook doesn't resolve the issue or if further assistance is needed.\n*   **Expected Outcomes:** What the system state should be after successful execution.\n*   **Associated Logs/Metrics:** Pointers to relevant logs or dashboards for investigation.\n\n**Evolution to Runbook Automation:**\nThe goal is to automate as many runbook procedures as possible to reduce manual toil, improve response times, and ensure consistency. This involves using scripting languages (Python, Bash), configuration management tools (Ansible), orchestration tools (Kubernetes operators), or specialized runbook automation platforms.\n\n**Example Scenario for a Runbook: High CPU Utilization on a Web Server**\n1.  **Trigger:** Alert: \"CPU utilization on webserver-01 > 90% for 5 minutes.\"\n2.  **Diagnosis Steps:**\n*   SSH into `webserver-01`.\n*   Run `top` or `htop` to identify high-CPU processes.\n*   Check application logs for errors related to the identified process (`/var/log/app/error.log`).\n*   Check web server access logs for unusual traffic patterns (`/var/log/nginx/access.log`).\n3.  **Possible Remediation Steps (based on diagnosis):**\n*   If it's a known memory leak in the application: Restart the application service (`sudo systemctl restart myapp`).\n*   If it's a sudden traffic spike: Consider temporarily scaling out if auto-scaling hasn't kicked in.\n*   If it's a rogue process: Identify and kill the process (use with caution).\n4.  **Verification:** Monitor CPU utilization for the next 15 minutes to ensure it returns to normal levels.\n5.  **Escalation:** If the issue persists, escalate to the on-call SRE for the web application.\n\n**Benefits of Well-Maintained Runbooks:**\n*   Faster Mean Time To Resolution (MTTR).\n*   Reduced operator errors.\n*   Improved operational consistency.\n*   Better knowledge sharing within the team.\n*   Facilitates automation efforts.",
    "tags": [
      "advanced",
      "cloud"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-97",
    "question": "What is a Playbook in Incident Response?",
    "answer": "An Incident Response Playbook is a specialized type of runbook focused specifically on guiding the actions of a response team during and after a secur...",
    "explanation": "An Incident Response Playbook is a specialized type of runbook focused specifically on guiding the actions of a response team during and after a security incident or significant operational outage. It provides a predefined and structured set of steps to detect, analyze, contain, eradicate, and recover from specific types of incidents.\n\n**Key Differences from General Runbooks:**\n*   **Focus:** Primarily on security incidents (e.g., data breach, malware infection, DDoS attack) or major service outages, whereas runbooks can cover routine operational tasks as well.\n*   **Goal:** To minimize the impact of an incident, restore service quickly and securely, and gather information for post-incident analysis and learning.\n*   **Audience:** Often used by security teams (CSIRT - Computer Security Incident Response Team), SREs, and operations staff involved in incident handling.\n\n**Core Components of an Incident Response Playbook:**\n1.  **Incident Type:** Clearly defines the specific incident the playbook addresses (e.g., \"Phishing Attack Leading to Credential Compromise,\" \"Ransomware Outbreak,\" \"Database Unavailability\").\n2.  **Roles and Responsibilities:** Identifies who is responsible for each action (e.g., Incident Commander, Communications Lead, Technical Lead).\n3.  **Preparation/Prerequisites:** Steps taken before an incident occurs (e.g., ensuring logging is enabled, access to necessary tools).\n4.  **Detection and Identification:** How to recognize that this specific type of incident is occurring (e.g., specific alerts, user reports, anomalous behavior).\n5.  **Containment Strategy:** Steps to limit the scope and impact of the incident (e.g., isolating affected systems, blocking malicious IPs, disabling compromised accounts).\n6.  **Eradication:** How to remove the cause of the incident (e.g., removing malware, patching vulnerabilities).\n7.  **Recovery:** Steps to restore affected systems and services to normal operation safely.\n8.  **Post-Incident Activities (Postmortem):** Procedures for analyzing the incident, documenting lessons learned, and improving defenses and response capabilities. This includes evidence preservation.\n9.  **Communication Plan:** Guidelines for internal and external communication (e.g., notifying stakeholders, legal, PR, customers if necessary).\n10. **Checklists and Decision Trees:** To guide responders through complex scenarios.\n11. **Tools and Resources:** List of necessary tools, contact information, and knowledge base articles.\n\n**Benefits of Incident Response Playbooks:**\n*   **Faster Response Times:** Enables quicker, more decisive action during high-stress situations.\n*   **Consistency:** Ensures a standardized approach to incident handling, regardless of who is responding.\n*   **Reduced Human Error:** Minimizes mistakes made under pressure.\n*   **Improved Decision Making:** Provides a framework for making critical decisions.\n*   **Compliance and Legal Adherence:** Helps meet regulatory requirements for incident response.\n*   **Effective Training Tool:** Can be used for drills and exercises to prepare teams.\n*   **Continuous Improvement:** Forms the basis for learning from incidents and refining response strategies.\n\n**Example Playbook Scenario: DDoS Attack Mitigation**\n*   **Detection:** Monitoring alerts for unusually high traffic volumes, high server load, and service unavailability.\n*   **Initial Triage:** Confirm it's a DDoS attack and not a legitimate traffic spike. Identify attack vectors (e.g., volumetric, protocol, application layer).\n*   **Containment/Mitigation:**\n*   Engage DDoS mitigation service (e.g., Cloudflare, AWS Shield).\n*   Implement rate limiting and IP blocking at edge firewalls/load balancers.\n*   Scale out backend resources if applicable.\n*   **Recovery:** Monitor traffic and service health. Gradually remove mitigation measures once the attack subsides.\n*   **Post-Incident:** Analyze attack patterns, identify vulnerabilities, update mitigation strategies, and document the incident.",
    "tags": [
      "advanced",
      "cloud"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-98",
    "question": "What is Observability?",
    "answer": "Observability is a measure of how well you can understand the internal state or condition of a complex system based only on knowledge of its external ...",
    "explanation": "Observability is a measure of how well you can understand the internal state or condition of a complex system based only on knowledge of its external outputs (logs, metrics, traces). It's about being able to ask arbitrary questions about your system's behavior without having to pre-define all possible failure modes or dashboards in advance. While monitoring tells you *whether* a system is working, observability helps you understand *why* it isn't (or is) working.\n\n**Three Pillars of Observability:**\n1.  **Logs:**\n*   **What:** Immutable, timestamped records of discrete events that happened over time. Logs provide detailed, context-rich information about specific occurrences.\n*   **Use Cases:** Debugging specific errors, auditing, understanding event sequences.\n*   **Examples:** Application logs (e.g., stack traces), system logs, audit logs, web server access logs.\n2.  **Metrics:**\n*   **What:** Aggregated numerical representations of data about your system measured over intervals of time. Metrics are good for understanding trends, patterns, and overall system health.\n*   **Use Cases:** Dashboarding, alerting on thresholds, capacity planning, trend analysis.\n*   **Examples:** CPU utilization, memory usage, request counts, error rates, queue lengths, latency percentiles.\n3.  **Traces (Distributed Tracing):**\n*   **What:** Show the lifecycle of a request as it flows through a distributed system. A single trace is composed of multiple \"spans,\" where each span represents a unit of work (e.g., an API call, a database query) within a service.\n*   **Use Cases:** Understanding request paths, identifying bottlenecks in distributed systems, debugging latency issues, visualizing service dependencies.\n*   **Examples:** A trace showing a user request hitting an API gateway, then an authentication service, then a product service, and finally a database.\n\n**Diagram: The Three Pillars**\n```mermaid\ngraph TD\nO[Observability] --> L[Logs]\nO --> M[Metrics]\nO --> T[Traces]\n\nL --Provides--> LD[Detailed Event Context]\nM --Provides--> MA[Aggregated System Health & Trends]\nT --Provides--> TP[Request Flow & Bottleneck Analysis]\n\nsubgraph System\nApp1[Application/Service 1]\nApp2[Application/Service 2]\nApp3[Infrastructure]\nend\n\nApp1 --> L\nApp1 --> M\nApp1 -- Generates Spans For --> T\nApp2 --> L\nApp2 --> M\nApp2 -- Generates Spans For --> T\nApp3 --> L\nApp3 --> M\n```\n\n**Why is Observability Important?**\n*   **Complex Systems:** Modern applications are often distributed, microservice-based, and run on dynamic infrastructure, making them harder to understand and debug.\n*   **Unknown Unknowns:** Observability helps investigate issues you didn't anticipate or for which you don't have pre-built dashboards.\n*   **Faster Debugging & MTTR:** Enables quicker root cause analysis when incidents occur.\n*   **Better Performance Understanding:** Provides deep insights into how different parts of the system interact and perform.\n*   **Proactive Issue Detection:** While often used reactively, rich observability data can help identify anomalies before they become major problems.\n\n**Monitoring vs. Observability:**\n*   **Monitoring:** Typically involves collecting predefined sets of metrics and alerting when these metrics cross certain thresholds. It answers known questions (e.g., \"Is the CPU over 80%?\").\n*   **Observability:** Provides the tools and data to explore and understand system behavior, enabling you to answer new questions about states you didn't predict. It helps explore the unknown unknowns.\nMonitoring is a part of observability, but observability encompasses a broader capability to interrogate your system.\n\n**Key Enablers for Observability:**\n*   **Rich Instrumentation:** Applications and infrastructure must be thoroughly instrumented to emit quality logs, metrics, and traces.\n*   **Correlation:** The ability to correlate data across logs, metrics, and traces is crucial (e.g., linking a specific log entry to a trace ID and relevant metrics).\n*   **High Cardinality Data:** Ability to analyze data with many unique attribute values (e.g., user IDs, request IDs).\n*   **Querying & Analytics:** Powerful tools to query, visualize, and analyze the collected telemetry data.",
    "tags": [
      "advanced",
      "cloud"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-99",
    "question": "What is Tracing in Observability?",
    "answer": "Tracing is the process of tracking the flow of requests through a distributed system, helping to identify bottlenecks and performance issues. Tools li...",
    "explanation": "Tracing is the process of tracking the flow of requests through a distributed system, helping to identify bottlenecks and performance issues. Tools like Jaeger and Zipkin are commonly used.",
    "tags": [
      "advanced",
      "cloud"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-100",
    "question": "What is a Sidecar Pattern?",
    "answer": "The Sidecar Pattern is a container-based design pattern where an auxiliary container (the \"sidecar\") is deployed alongside the main application contai...",
    "explanation": "The Sidecar Pattern is a container-based design pattern where an auxiliary container (the \"sidecar\") is deployed alongside the main application container within the same deployment unit (e.g., a Kubernetes Pod). The sidecar container enhances or extends the functionality of the main application container by providing supporting features, and they share resources like networking and storage.\n\n**Key Characteristics:**\n1.  **Co-location:** The main application container and the sidecar container(s) run together in the same Pod (in Kubernetes) or task definition (in ECS).\n2.  **Shared Lifecycle:** Sidecars are typically started and stopped with the main application container.\n3.  **Shared Resources:** They share the same network namespace (can communicate via `localhost`) and can share volumes for data exchange.\n4.  **Encapsulation & Separation of Concerns:** The sidecar encapsulates common functionalities (like logging, monitoring, proxying) that would otherwise need to be built into each application or run as separate agents on the host.\n5.  **Language Agnostic:** Sidecars can be written in different languages than the main application, allowing teams to use the best tool for the job for auxiliary tasks.\n\n**Diagram: Sidecar Pattern in a Kubernetes Pod**\n```mermaid\ngraph TD\nsubgraph Kubernetes Pod\ndirection LR\nAppContainer[Main Application Container]\nSidecarContainer[Sidecar Container]\nAppContainer -- localhost --> SidecarContainer\nSidecarContainer -- localhost --> AppContainer\nsubgraph Shared Resources\nNetwork[Shared Network Namespace]\nVolumes[Shared Volumes]\nend\nAppContainer --> Network\nSidecarContainer --> Network\nAppContainer --> Volumes\nSidecarContainer --> Volumes\nend\nExternalTraffic --> Network\nNetwork --> ExternalServices\n```\n\n**Common Use Cases for Sidecars:**\n*   **Log Aggregation:** A sidecar (e.g., Fluentd, Fluent Bit) collects logs from the main application container (e.g., from stdout/stderr or a shared volume) and forwards them to a centralized logging system.\n*   **Metrics Collection:** A sidecar exports metrics from the application (e.g., Prometheus exporter) or provides a metrics endpoint.\n*   **Service Mesh Proxy:** In a service mesh (e.g., Istio, Linkerd), a sidecar proxy (e.g., Envoy) runs alongside each application instance to manage network traffic, enforce policies, provide security (mTLS), and collect telemetry.\n*   **Configuration Management:** A sidecar can fetch configuration updates from a central store and make them available to the main application, or reload the application when configuration changes.\n*   **Secrets Management:** A sidecar can fetch secrets from a vault and inject them into the application environment or a shared volume.\n*   **Network Utilities:** Providing network-related functions like SSL/TLS termination, circuit breaking, or acting as a reverse proxy.\n*   **File Synchronization:** Syncing files from a remote source (like Git or S3) to a shared volume for the application to use.\n\n**Benefits:**\n*   **Modularity and Reusability:** Common functionalities can be developed and deployed as separate sidecar containers, reusable across multiple applications.\n*   **Reduced Application Complexity:** Keeps the main application focused on its core business logic.\n*   **Independent Upgrades:** Sidecar functionalities can be updated independently of the main application.\n*   **Polyglot Environments:** Allows auxiliary functions to be written in different languages/technologies.\n*   **Encapsulation:** Isolates auxiliary tasks from the main application.\n\n**Considerations:**\n*   **Resource Overhead:** Each sidecar consumes additional resources (CPU, memory).\n*   **Increased Complexity (Deployment Unit):** While simplifying the application, it makes the deployment unit (Pod) more complex with multiple containers.\n*   **Inter-Process Communication:** Communication between the app and sidecar (though often via localhost or shared volumes) needs to be efficient.",
    "tags": [
      "advanced",
      "cloud"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-101",
    "question": "What is a Service Mesh Control Plane?",
    "answer": "In a service mesh architecture, the Control Plane is the centralized component responsible for configuring, managing, and monitoring the behavior of t...",
    "explanation": "In a service mesh architecture, the **Control Plane** is the centralized component responsible for configuring, managing, and monitoring the behavior of the data plane proxies (typically sidecar proxies like Envoy) that run alongside each service instance. It does not handle any of the actual request traffic between services; that is the role of the data plane.\n\n**Key Responsibilities of a Service Mesh Control Plane:**\n1.  **Configuration Distribution:**\n*   It pushes configuration updates (e.g., routing rules, traffic policies, security policies, telemetry configurations) to all the sidecar proxies in the mesh.\n*   This allows dynamic changes to traffic flow and policies without restarting services or proxies.\n2.  **Service Discovery:**\n*   Provides an up-to-date registry of all services and their instances within the mesh, enabling proxies to know where to route traffic.\n*   Often integrates with the underlying platform's service discovery (e.g., Kubernetes DNS, Consul).\n3.  **Policy Enforcement Configuration:**\n*   Defines and distributes policies related to security (e.g., mTLS requirements, authorization rules), traffic management (e.g., retries, timeouts, circuit breakers), and rate limiting.\n*   The control plane tells the proxies *what* policies to enforce; the proxies do the actual enforcement.\n4.  **Certificate Management:**\n*   Manages the lifecycle of TLS certificates used for mutual TLS (mTLS) authentication between services, ensuring secure communication.\n*   Distributes certificates and keys to the proxies.\n5.  **Telemetry Aggregation (or Configuration for it):**\n*   While proxies collect raw telemetry data (metrics, logs, traces), the control plane often provides a central point to configure what telemetry is collected and where it should be sent. Some control planes may also aggregate certain metrics.\n6.  **API for Operators:**\n*   Exposes APIs and CLIs for operators to interact with the service mesh, define configurations, and observe its state.\n\n**Interaction with Data Plane:**\n```mermaid\ngraph TD\nCP[\"Control Plane\"] -->|Config| DP1[\"Proxy 1\"]\nCP -->|Config| DP2[\"Proxy 2\"]\nS1[Service A] <--> DP1\nS2[Service B] <--> DP2\nDP1 <-->|Traffic| DP2\nDP1 -->|Telemetry| O[\"Observability\"]\nDP2 -->|Telemetry| O\n```\n*   The Control Plane configures the Data Plane proxies.\n*   The Data Plane proxies handle all request traffic between services based on the configuration received from the Control Plane.\n*   The Data Plane proxies send telemetry data back to monitoring/observability systems (often configured via the Control Plane).\n\n**Popular Service Mesh Control Planes:**\n*   **Istio:** `istiod` is the control plane daemon.\n*   **Linkerd:** The control plane is composed of several components (e.g., `controller`, `destination`).\n*   **Consul Connect:** Consul servers act as the control plane.\n*   **Kuma/Kong Mesh:** `kuma-cp` is the control plane.\n\n**Benefits of a Separate Control Plane:**\n*   **Centralized Management:** Provides a single point of control and visibility over the entire service mesh.\n*   **Decoupling:** Separates the management logic from the request processing logic, making the system more modular and resilient.\n*   **Scalability:** The control plane can be scaled independently of the data plane.\n*   **Dynamic Configuration:** Enables runtime changes to traffic management and policies without service restarts.",
    "tags": [
      "advanced",
      "cloud"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-102",
    "question": "What is GitHub Actions?",
    "answer": "GitHub Actions is a CI/CD and automation platform built into GitHub that allows you to automate workflows for building, testing, and deploying code di...",
    "explanation": "GitHub Actions is a CI/CD and automation platform built into GitHub that allows you to automate workflows for building, testing, and deploying code directly from your repository.",
    "tags": [
      "advanced",
      "cloud"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-103",
    "question": "What is a Self-Healing System?",
    "answer": "A Self-Healing System is an architecture that can automatically detect and recover from failures, often using automation, monitoring, and orchestratio...",
    "explanation": "A Self-Healing System is an architecture that can automatically detect and recover from failures, often using automation, monitoring, and orchestration tools to maintain availability.",
    "tags": [
      "advanced",
      "cloud"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-104",
    "question": "What is Canary Analysis?",
    "answer": "Canary Analysis is a deployment strategy that releases changes to a small subset of users or servers before rolling out to the entire infrastructure, ...",
    "explanation": "Canary Analysis is a deployment strategy that releases changes to a small subset of users or servers before rolling out to the entire infrastructure, allowing for early detection of issues.",
    "tags": [
      "advanced",
      "cloud"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "gh-105",
    "question": "What is Infrastructure Drift?",
    "answer": "Infrastructure Drift occurs when the actual state of infrastructure diverges from the desired state defined in code, often due to manual changes or co...",
    "explanation": "Infrastructure Drift occurs when the actual state of infrastructure diverges from the desired state defined in code, often due to manual changes or configuration errors. Tools like Terraform and Ansible can help detect and correct drift.",
    "tags": [
      "advanced",
      "cloud"
    ],
    "difficulty": "advanced",
    "channel": "devops",
    "subChannel": "general"
  },
  {
    "id": "sr-124",
    "question": "What are the four golden signals of monitoring?",
    "answer": "Latency, Traffic, Errors, and Saturation - key metrics for service health.",
    "explanation": "**The Four Golden Signals**:\n\n1. **Latency**: Time to serve a request\n2. **Traffic**: Demand on your system (requests/sec)\n3. **Errors**: Rate of failed requests\n4. **Saturation**: How full your service is (CPU, memory)\n\nThese signals help identify issues before they become outages.",
    "tags": [
      "metrics",
      "monitoring"
    ],
    "difficulty": "beginner",
    "channel": "sre",
    "subChannel": "observability",
    "diagram": "graph TD\n    M[Monitoring] --> L[Latency]\n    M --> T[Traffic]\n    M --> E[Errors]\n    M --> S[Saturation]"
  }
]