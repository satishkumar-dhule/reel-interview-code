/**
 * Test System - Quiz functionality for knowledge assessment
 * Tests are generated by test-bot per module with 25-50 questions
 * Each test session offers 20 random questions
 */

export interface TestOption {
  id: string;
  text: string;
  isCorrect: boolean;
}

export interface TestQuestion {
  id: string;
  questionId: string; // Reference to original question
  question: string;
  type: 'single' | 'multiple'; // single choice or multiple answer
  options: TestOption[];
  explanation?: string;
  difficulty: 'beginner' | 'intermediate' | 'advanced';
}

export interface Test {
  id: string;
  channelId: string;
  channelName: string;
  title: string;
  description: string;
  questions: TestQuestion[];
  passingScore: number; // percentage
  timeLimit?: number; // minutes, optional
  createdAt: string;
  version: number;
}

export interface TestAttempt {
  testId: string;
  startedAt: string;
  completedAt?: string;
  answers: Record<string, string[]>; // questionId -> selected option ids
  score?: number;
  passed?: boolean;
  timeSpent?: number; // seconds
}

export interface TestProgress {
  testId: string;
  channelId: string;
  attempts: TestAttempt[];
  bestScore: number;
  lastAttemptAt?: string;
  passed: boolean;
}

// Storage keys
const TESTS_STORAGE_KEY = 'channel-tests';
const TEST_PROGRESS_KEY = 'test-progress';
const TEST_PROMPT_DISMISSED_KEY = 'test-prompt-dismissed';

// Get all available tests (loaded from static JSON)
let testsCache: Test[] | null = null;

export async function loadTests(): Promise<Test[]> {
  if (testsCache) return testsCache;
  
  try {
    const response = await fetch('/data/tests.json');
    if (!response.ok) return [];
    testsCache = await response.json();
    return testsCache || [];
  } catch {
    return [];
  }
}

// Get test for a specific channel
export async function getTestForChannel(channelId: string): Promise<Test | null> {
  const tests = await loadTests();
  return tests.find(t => t.channelId === channelId) || null;
}

// Get all test progress from localStorage
export function getAllTestProgress(): Record<string, TestProgress> {
  try {
    const stored = localStorage.getItem(TEST_PROGRESS_KEY);
    return stored ? JSON.parse(stored) : {};
  } catch {
    return {};
  }
}

// Get progress for a specific test
export function getTestProgress(testId: string): TestProgress | null {
  const all = getAllTestProgress();
  return all[testId] || null;
}

// Save test attempt
export function saveTestAttempt(testId: string, channelId: string, attempt: TestAttempt): void {
  const all = getAllTestProgress();
  
  if (!all[testId]) {
    all[testId] = {
      testId,
      channelId,
      attempts: [],
      bestScore: 0,
      passed: false,
    };
  }
  
  all[testId].attempts.push(attempt);
  all[testId].lastAttemptAt = attempt.completedAt;
  
  if (attempt.score !== undefined) {
    if (attempt.score > all[testId].bestScore) {
      all[testId].bestScore = attempt.score;
    }
    if (attempt.passed) {
      all[testId].passed = true;
    }
  }
  
  localStorage.setItem(TEST_PROGRESS_KEY, JSON.stringify(all));
}

// Calculate score for an attempt
export function calculateScore(test: Test, answers: Record<string, string[]>): { 
  score: number; 
  correct: number; 
  total: number;
  passed: boolean;
} {
  let correct = 0;
  const total = test.questions.length;
  
  test.questions.forEach(q => {
    const userAnswers = answers[q.id] || [];
    const correctOptions = q.options.filter(o => o.isCorrect).map(o => o.id);
    
    if (q.type === 'single') {
      // Single choice: exact match
      if (userAnswers.length === 1 && correctOptions.includes(userAnswers[0])) {
        correct++;
      }
    } else {
      // Multiple choice: all correct and no incorrect
      const allCorrectSelected = correctOptions.every(id => userAnswers.includes(id));
      const noIncorrectSelected = userAnswers.every(id => correctOptions.includes(id));
      if (allCorrectSelected && noIncorrectSelected && userAnswers.length > 0) {
        correct++;
      }
    }
  });
  
  const score = Math.round((correct / total) * 100);
  return { score, correct, total, passed: score >= test.passingScore };
}

// Shuffle array helper (Fisher-Yates)
function shuffleArray<T>(array: T[]): T[] {
  const shuffled = [...array];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
}

// Get random questions for a test session with randomized options
export function getSessionQuestions(test: Test, count: number = 20): TestQuestion[] {
  // Shuffle questions
  const shuffledQuestions = shuffleArray(test.questions);
  
  // Take the requested count
  const selectedQuestions = shuffledQuestions.slice(0, Math.min(count, test.questions.length));
  
  // Randomize options for each question
  return selectedQuestions.map(q => ({
    ...q,
    options: shuffleArray(q.options)
  }));
}

// Check if test prompt was dismissed for a channel
export function isTestPromptDismissed(channelId: string): boolean {
  try {
    const stored = localStorage.getItem(TEST_PROMPT_DISMISSED_KEY);
    const dismissed = stored ? JSON.parse(stored) : {};
    return !!dismissed[channelId];
  } catch {
    return false;
  }
}

// Dismiss test prompt for a channel
export function dismissTestPrompt(channelId: string): void {
  try {
    const stored = localStorage.getItem(TEST_PROMPT_DISMISSED_KEY);
    const dismissed = stored ? JSON.parse(stored) : {};
    dismissed[channelId] = Date.now();
    localStorage.setItem(TEST_PROMPT_DISMISSED_KEY, JSON.stringify(dismissed));
  } catch {
    // Ignore
  }
}

// Generate shareable badge URL
export function generateShareableBadge(
  channelName: string,
  score: number,
  passed: boolean
): string {
  const badge = passed ? 'âœ…' : 'ðŸ“Š';
  const text = `${badge} I scored ${score}% on the ${channelName} test on Code Reels!`;
  const url = 'https://open-interview.github.io/';
  
  return `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(url)}`;
}

// Generate social share URL
export function generateSocialShare(
  channelName: string,
  score: number,
  passed: boolean
): string {
  const url = 'https://open-interview.github.io/';
  return `https://www.linkedin.com/sharing/share-offsite/?url=${encodeURIComponent(url)}`;
}

// Get test stats summary
export function getTestStats(): {
  totalTests: number;
  passedTests: number;
  totalAttempts: number;
  averageScore: number;
} {
  const progress = getAllTestProgress();
  const entries = Object.values(progress);
  
  const totalTests = entries.length;
  const passedTests = entries.filter(p => p.passed).length;
  const totalAttempts = entries.reduce((sum, p) => sum + p.attempts.length, 0);
  
  const scores = entries.map(p => p.bestScore).filter(s => s > 0);
  const averageScore = scores.length > 0 
    ? Math.round(scores.reduce((a, b) => a + b, 0) / scores.length)
    : 0;
  
  return { totalTests, passedTests, totalAttempts, averageScore };
}
