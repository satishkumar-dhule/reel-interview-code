/**
 * Test System - Quiz functionality for knowledge assessment
 * Tests are generated by test-bot per module with 25-50 questions
 * Each test session offers 20 random questions
 * 
 * VIBRANT CHANNEL-BASED TESTS:
 * - Each channel has a unique color theme
 * - Pass status expires when new questions are added
 * - RAG-based progressive question selection
 */

export interface TestOption {
  id: string;
  text: string;
  isCorrect: boolean;
}

export interface TestQuestion {
  id: string;
  questionId: string; // Reference to original question
  question: string;
  type: 'single' | 'multiple'; // single choice or multiple answer
  options: TestOption[];
  explanation?: string;
  difficulty: 'beginner' | 'intermediate' | 'advanced';
}

export interface Test {
  id: string;
  channelId: string;
  channelName: string;
  title: string;
  description: string;
  questions: TestQuestion[];
  passingScore: number; // percentage
  timeLimit?: number; // minutes, optional
  createdAt: string;
  version: number;
  lastUpdated?: string;
}

export interface TestAttempt {
  testId: string;
  startedAt: string;
  completedAt?: string;
  answers: Record<string, string[]>; // questionId -> selected option ids
  score?: number;
  passed?: boolean;
  timeSpent?: number; // seconds
}

export interface TestProgress {
  testId: string;
  channelId: string;
  attempts: TestAttempt[];
  bestScore: number;
  lastAttemptAt?: string;
  passed: boolean;
  passedVersion?: number; // Track which version was passed
  passedAt?: string; // When the test was passed
  expired?: boolean; // Whether pass status has expired due to new questions
}

// Channel theme configuration for vibrant UI
export interface ChannelTheme {
  primary: string;
  secondary: string;
  gradient: string;
  glow: string;
  badge: string;
  icon: string;
}

// Vibrant channel themes
export const CHANNEL_THEMES: Record<string, ChannelTheme> = {
  aws: {
    primary: 'text-orange-500',
    secondary: 'bg-orange-500/20',
    gradient: 'from-orange-500/20 via-amber-500/10 to-yellow-500/20',
    glow: 'shadow-orange-500/30',
    badge: 'bg-orange-500',
    icon: '‚òÅÔ∏è'
  },
  algorithms: {
    primary: 'text-purple-500',
    secondary: 'bg-purple-500/20',
    gradient: 'from-purple-500/20 via-violet-500/10 to-indigo-500/20',
    glow: 'shadow-purple-500/30',
    badge: 'bg-purple-500',
    icon: 'üßÆ'
  },
  'system-design': {
    primary: 'text-blue-500',
    secondary: 'bg-blue-500/20',
    gradient: 'from-blue-500/20 via-cyan-500/10 to-teal-500/20',
    glow: 'shadow-blue-500/30',
    badge: 'bg-blue-500',
    icon: 'üèóÔ∏è'
  },
  frontend: {
    primary: 'text-cyan-500',
    secondary: 'bg-cyan-500/20',
    gradient: 'from-cyan-500/20 via-sky-500/10 to-blue-500/20',
    glow: 'shadow-cyan-500/30',
    badge: 'bg-cyan-500',
    icon: 'üé®'
  },
  backend: {
    primary: 'text-green-500',
    secondary: 'bg-green-500/20',
    gradient: 'from-green-500/20 via-emerald-500/10 to-teal-500/20',
    glow: 'shadow-green-500/30',
    badge: 'bg-green-500',
    icon: '‚öôÔ∏è'
  },
  devops: {
    primary: 'text-indigo-500',
    secondary: 'bg-indigo-500/20',
    gradient: 'from-indigo-500/20 via-blue-500/10 to-violet-500/20',
    glow: 'shadow-indigo-500/30',
    badge: 'bg-indigo-500',
    icon: 'üîÑ'
  },
  kubernetes: {
    primary: 'text-sky-500',
    secondary: 'bg-sky-500/20',
    gradient: 'from-sky-500/20 via-blue-500/10 to-indigo-500/20',
    glow: 'shadow-sky-500/30',
    badge: 'bg-sky-500',
    icon: '‚ò∏Ô∏è'
  },
  database: {
    primary: 'text-amber-500',
    secondary: 'bg-amber-500/20',
    gradient: 'from-amber-500/20 via-yellow-500/10 to-orange-500/20',
    glow: 'shadow-amber-500/30',
    badge: 'bg-amber-500',
    icon: 'üóÑÔ∏è'
  },
  security: {
    primary: 'text-red-500',
    secondary: 'bg-red-500/20',
    gradient: 'from-red-500/20 via-rose-500/10 to-pink-500/20',
    glow: 'shadow-red-500/30',
    badge: 'bg-red-500',
    icon: 'üîí'
  },
  'machine-learning': {
    primary: 'text-pink-500',
    secondary: 'bg-pink-500/20',
    gradient: 'from-pink-500/20 via-rose-500/10 to-red-500/20',
    glow: 'shadow-pink-500/30',
    badge: 'bg-pink-500',
    icon: 'ü§ñ'
  },
  testing: {
    primary: 'text-emerald-500',
    secondary: 'bg-emerald-500/20',
    gradient: 'from-emerald-500/20 via-green-500/10 to-teal-500/20',
    glow: 'shadow-emerald-500/30',
    badge: 'bg-emerald-500',
    icon: 'üß™'
  },
  behavioral: {
    primary: 'text-violet-500',
    secondary: 'bg-violet-500/20',
    gradient: 'from-violet-500/20 via-purple-500/10 to-indigo-500/20',
    glow: 'shadow-violet-500/30',
    badge: 'bg-violet-500',
    icon: 'üí¨'
  },
  sre: {
    primary: 'text-rose-500',
    secondary: 'bg-rose-500/20',
    gradient: 'from-rose-500/20 via-pink-500/10 to-red-500/20',
    glow: 'shadow-rose-500/30',
    badge: 'bg-rose-500',
    icon: 'üîß'
  },
  terraform: {
    primary: 'text-violet-600',
    secondary: 'bg-violet-600/20',
    gradient: 'from-violet-600/20 via-purple-500/10 to-indigo-500/20',
    glow: 'shadow-violet-600/30',
    badge: 'bg-violet-600',
    icon: 'üèîÔ∏è'
  },
  networking: {
    primary: 'text-teal-500',
    secondary: 'bg-teal-500/20',
    gradient: 'from-teal-500/20 via-cyan-500/10 to-blue-500/20',
    glow: 'shadow-teal-500/30',
    badge: 'bg-teal-500',
    icon: 'üåê'
  },
  linux: {
    primary: 'text-yellow-600',
    secondary: 'bg-yellow-600/20',
    gradient: 'from-yellow-600/20 via-amber-500/10 to-orange-500/20',
    glow: 'shadow-yellow-600/30',
    badge: 'bg-yellow-600',
    icon: 'üêß'
  },
  python: {
    primary: 'text-blue-400',
    secondary: 'bg-blue-400/20',
    gradient: 'from-blue-400/20 via-yellow-500/10 to-green-500/20',
    glow: 'shadow-blue-400/30',
    badge: 'bg-blue-400',
    icon: 'üêç'
  },
  'generative-ai': {
    primary: 'text-fuchsia-500',
    secondary: 'bg-fuchsia-500/20',
    gradient: 'from-fuchsia-500/20 via-pink-500/10 to-purple-500/20',
    glow: 'shadow-fuchsia-500/30',
    badge: 'bg-fuchsia-500',
    icon: '‚ú®'
  },
  default: {
    primary: 'text-primary',
    secondary: 'bg-primary/20',
    gradient: 'from-primary/20 via-primary/10 to-primary/20',
    glow: 'shadow-primary/30',
    badge: 'bg-primary',
    icon: 'üìö'
  }
};

// Get theme for a channel
export function getChannelTheme(channelId: string): ChannelTheme {
  return CHANNEL_THEMES[channelId] || CHANNEL_THEMES.default;
}

// Storage keys
const TESTS_STORAGE_KEY = 'channel-tests';
const TEST_PROGRESS_KEY = 'test-progress';
const TEST_PROMPT_DISMISSED_KEY = 'test-prompt-dismissed';
const CHANNEL_VERSIONS_KEY = 'channel-test-versions';

// Get all available tests (loaded from static JSON)
let testsCache: Test[] | null = null;

export async function loadTests(): Promise<Test[]> {
  if (testsCache) return testsCache;
  
  try {
    const response = await fetch('/data/tests.json');
    if (!response.ok) return [];
    testsCache = await response.json();
    return testsCache || [];
  } catch {
    return [];
  }
}

// Get test for a specific channel
export async function getTestForChannel(channelId: string): Promise<Test | null> {
  const tests = await loadTests();
  return tests.find(t => t.channelId === channelId) || null;
}

// Get stored channel versions for expiration tracking
function getStoredChannelVersions(): Record<string, { version: number; questionCount: number }> {
  try {
    const stored = localStorage.getItem(CHANNEL_VERSIONS_KEY);
    return stored ? JSON.parse(stored) : {};
  } catch {
    return {};
  }
}

// Save channel versions
function saveChannelVersions(versions: Record<string, { version: number; questionCount: number }>): void {
  try {
    localStorage.setItem(CHANNEL_VERSIONS_KEY, JSON.stringify(versions));
  } catch {
    // Ignore storage errors
  }
}

// Check if a test's pass status should be expired
export function checkTestExpiration(test: Test, progress: TestProgress | null): boolean {
  if (!progress || !progress.passed) return false;
  
  const storedVersions = getStoredChannelVersions();
  const storedVersion = storedVersions[test.channelId];
  
  // If we have a stored version and the test version is newer, expire the pass
  if (storedVersion && test.version > storedVersion.version) {
    return true;
  }
  
  // If question count increased significantly (10%+), expire the pass
  if (storedVersion && test.questions.length > storedVersion.questionCount * 1.1) {
    return true;
  }
  
  // Check if passed version is older than current test version
  if (progress.passedVersion && test.version > progress.passedVersion) {
    return true;
  }
  
  return false;
}

// Update channel version tracking after viewing a test
export function updateChannelVersion(test: Test): void {
  const versions = getStoredChannelVersions();
  versions[test.channelId] = {
    version: test.version,
    questionCount: test.questions.length
  };
  saveChannelVersions(versions);
}

// Get all test progress from localStorage with expiration check
export function getAllTestProgress(): Record<string, TestProgress> {
  try {
    const stored = localStorage.getItem(TEST_PROGRESS_KEY);
    return stored ? JSON.parse(stored) : {};
  } catch {
    return {};
  }
}

// Get progress for a specific test with expiration check
export function getTestProgress(testId: string): TestProgress | null {
  const all = getAllTestProgress();
  return all[testId] || null;
}

// Check and mark expired tests
export async function checkAndExpireTests(): Promise<string[]> {
  const tests = await loadTests();
  const progress = getAllTestProgress();
  const expiredChannels: string[] = [];
  
  for (const test of tests) {
    const testProgress = progress[test.id];
    if (testProgress && testProgress.passed && checkTestExpiration(test, testProgress)) {
      // Mark as expired
      testProgress.expired = true;
      testProgress.passed = false;
      expiredChannels.push(test.channelId);
    }
    // Update version tracking
    updateChannelVersion(test);
  }
  
  if (expiredChannels.length > 0) {
    localStorage.setItem(TEST_PROGRESS_KEY, JSON.stringify(progress));
  }
  
  return expiredChannels;
}

// Save test attempt with version tracking
export function saveTestAttempt(testId: string, channelId: string, attempt: TestAttempt, testVersion?: number): void {
  const all = getAllTestProgress();
  
  if (!all[testId]) {
    all[testId] = {
      testId,
      channelId,
      attempts: [],
      bestScore: 0,
      passed: false,
    };
  }
  
  all[testId].attempts.push(attempt);
  all[testId].lastAttemptAt = attempt.completedAt;
  
  if (attempt.score !== undefined) {
    if (attempt.score > all[testId].bestScore) {
      all[testId].bestScore = attempt.score;
    }
    if (attempt.passed) {
      all[testId].passed = true;
      all[testId].passedAt = attempt.completedAt;
      all[testId].passedVersion = testVersion;
      all[testId].expired = false;
    }
  }
  
  localStorage.setItem(TEST_PROGRESS_KEY, JSON.stringify(all));
}

// Calculate score for an attempt
export function calculateScore(test: Test, answers: Record<string, string[]>): { 
  score: number; 
  correct: number; 
  total: number;
  passed: boolean;
} {
  let correct = 0;
  const total = test.questions.length;
  
  test.questions.forEach(q => {
    const userAnswers = answers[q.id] || [];
    const correctOptions = q.options.filter(o => o.isCorrect).map(o => o.id);
    
    if (q.type === 'single') {
      // Single choice: exact match
      if (userAnswers.length === 1 && correctOptions.includes(userAnswers[0])) {
        correct++;
      }
    } else {
      // Multiple choice: all correct and no incorrect
      const allCorrectSelected = correctOptions.every(id => userAnswers.includes(id));
      const noIncorrectSelected = userAnswers.every(id => correctOptions.includes(id));
      if (allCorrectSelected && noIncorrectSelected && userAnswers.length > 0) {
        correct++;
      }
    }
  });
  
  const score = Math.round((correct / total) * 100);
  return { score, correct, total, passed: score >= test.passingScore };
}

// Shuffle array helper (Fisher-Yates)
function shuffleArray<T>(array: T[]): T[] {
  const shuffled = [...array];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
}

/**
 * Calculate semantic similarity between two questions using keyword matching
 */
function calculateQuestionSimilarity(q1: TestQuestion, q2: TestQuestion): number {
  let score = 0;

  // Same difficulty: +0.2
  if (q1.difficulty === q2.difficulty) {
    score += 0.2;
  }

  // Extract keywords from questions
  const keywords1 = extractKeywords(q1.question);
  const keywords2 = extractKeywords(q2.question);

  // Keyword overlap
  const commonKeywords = keywords1.filter(k => keywords2.includes(k));
  const keywordScore = commonKeywords.length / Math.max(keywords1.length, keywords2.length, 1);
  score += keywordScore * 0.5;

  // Question length similarity (prefer similar complexity)
  const lengthRatio = Math.min(q1.question.length, q2.question.length) / 
                      Math.max(q1.question.length, q2.question.length);
  score += lengthRatio * 0.3;

  return Math.min(score, 1.0);
}

/**
 * Extract keywords from question text
 */
function extractKeywords(text: string): string[] {
  const stopWords = new Set([
    'what', 'how', 'why', 'when', 'where', 'which', 'who',
    'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at',
    'to', 'for', 'of', 'with', 'by', 'from', 'is', 'are',
    'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had',
    'do', 'does', 'did', 'will', 'would', 'should', 'could',
    'can', 'may', 'might', 'must', 'shall'
  ]);

  return text
    .toLowerCase()
    .replace(/[^a-z0-9\s-]/g, ' ')
    .split(/\s+/)
    .filter(word => word.length > 3 && !stopWords.has(word))
    .slice(0, 10);
}

/**
 * Determine target difficulty based on recent performance
 */
function determineTargetDifficulty(
  currentLevel: 'beginner' | 'intermediate' | 'advanced',
  recentAccuracy: number,
  totalAnswered: number
): 'beginner' | 'intermediate' | 'advanced' {
  // Start with beginner for first few questions
  if (totalAnswered < 2) return 'beginner';

  // If doing well (>70% accuracy), increase difficulty
  if (recentAccuracy > 0.7) {
    if (currentLevel === 'beginner') return 'intermediate';
    if (currentLevel === 'intermediate') return 'advanced';
    return 'advanced';
  }

  // If struggling (<40% accuracy), decrease difficulty
  if (recentAccuracy < 0.4) {
    if (currentLevel === 'advanced') return 'intermediate';
    if (currentLevel === 'intermediate') return 'beginner';
    return 'beginner';
  }

  // Otherwise maintain current level
  return currentLevel;
}

/**
 * Get progressive questions using RAG-based selection
 * Questions are selected based on semantic similarity and adaptive difficulty
 * 
 * IMPORTANT: Uses Set to track selected question IDs to prevent duplicates
 */
export function getSessionQuestions(test: Test, count: number = 20): TestQuestion[] {
  const maxCount = Math.min(count, test.questions.length);
  if (maxCount === 0) return [];

  const selectedQuestions: TestQuestion[] = [];
  const selectedIds = new Set<string>(); // Track selected question IDs to prevent duplicates
  let currentDifficulty: 'beginner' | 'intermediate' | 'advanced' = 'beginner';
  let performanceHistory: boolean[] = [];

  // Helper to get available questions (not yet selected)
  const getAvailable = () => test.questions.filter(q => !selectedIds.has(q.id));

  for (let i = 0; i < maxCount; i++) {
    const availableQuestions = getAvailable();
    if (availableQuestions.length === 0) break;

    let nextQuestion: TestQuestion;

    if (i === 0) {
      // First question: random beginner or intermediate
      const easyQuestions = availableQuestions.filter(
        q => q.difficulty === 'beginner' || q.difficulty === 'intermediate'
      );
      const pool = easyQuestions.length > 0 ? easyQuestions : availableQuestions;
      nextQuestion = pool[Math.floor(Math.random() * pool.length)];
    } else {
      // Calculate recent accuracy
      const recentPerformance = performanceHistory.slice(-3);
      const recentAccuracy = recentPerformance.length > 0
        ? recentPerformance.filter(Boolean).length / recentPerformance.length
        : 0.5;

      // Determine target difficulty
      const targetDifficulty = determineTargetDifficulty(
        currentDifficulty,
        recentAccuracy,
        i
      );
      currentDifficulty = targetDifficulty;

      // Filter by difficulty from available questions only
      const difficultyFiltered = availableQuestions.filter(
        q => q.difficulty === targetDifficulty
      );
      const candidatePool = difficultyFiltered.length > 0 
        ? difficultyFiltered 
        : availableQuestions;

      // Calculate similarity scores with previous question
      const previousQuestion = selectedQuestions[i - 1];
      const scored = candidatePool.map(q => ({
        question: q,
        score: calculateQuestionSimilarity(previousQuestion, q)
      }));

      // Sort by relevance and pick from top 5 to add variety
      scored.sort((a, b) => b.score - a.score);
      const topCandidates = scored.slice(0, Math.min(5, scored.length));
      nextQuestion = topCandidates[Math.floor(Math.random() * topCandidates.length)].question;
    }

    // Add to selected and mark as used
    selectedQuestions.push(nextQuestion);
    selectedIds.add(nextQuestion.id);

    // Simulate performance for next selection (assume 60% success rate)
    performanceHistory.push(Math.random() > 0.4);
  }

  // Randomize options for each question
  return selectedQuestions.map(q => ({
    ...q,
    options: shuffleArray(q.options)
  }));
}

// Check if test prompt was dismissed for a channel
export function isTestPromptDismissed(channelId: string): boolean {
  try {
    const stored = localStorage.getItem(TEST_PROMPT_DISMISSED_KEY);
    const dismissed = stored ? JSON.parse(stored) : {};
    return !!dismissed[channelId];
  } catch {
    return false;
  }
}

// Dismiss test prompt for a channel
export function dismissTestPrompt(channelId: string): void {
  try {
    const stored = localStorage.getItem(TEST_PROMPT_DISMISSED_KEY);
    const dismissed = stored ? JSON.parse(stored) : {};
    dismissed[channelId] = Date.now();
    localStorage.setItem(TEST_PROMPT_DISMISSED_KEY, JSON.stringify(dismissed));
  } catch {
    // Ignore
  }
}

// Generate shareable badge URL
export function generateShareableBadge(
  channelName: string,
  score: number,
  passed: boolean
): string {
  const badge = passed ? '‚úÖ' : 'üìä';
  const text = `${badge} I scored ${score}% on the ${channelName} test on Code Reels!`;
  const url = 'https://open-interview.github.io/';
  
  return `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(url)}`;
}

// Generate social share URL
export function generateSocialShare(
  channelName: string,
  score: number,
  passed: boolean
): string {
  const url = 'https://open-interview.github.io/';
  return `https://www.linkedin.com/sharing/share-offsite/?url=${encodeURIComponent(url)}`;
}

// Get test stats summary
export function getTestStats(): {
  totalTests: number;
  passedTests: number;
  totalAttempts: number;
  averageScore: number;
} {
  const progress = getAllTestProgress();
  const entries = Object.values(progress);
  
  const totalTests = entries.length;
  const passedTests = entries.filter(p => p.passed).length;
  const totalAttempts = entries.reduce((sum, p) => sum + p.attempts.length, 0);
  
  const scores = entries.map(p => p.bestScore).filter(s => s > 0);
  const averageScore = scores.length > 0 
    ? Math.round(scores.reduce((a, b) => a + b, 0) / scores.length)
    : 0;
  
  return { totalTests, passedTests, totalAttempts, averageScore };
}
