{
  "id": "gh-66",
  "question": "How does serverless computing abstract infrastructure management and what are its key execution characteristics?",
  "answer": "Serverless computing abstracts infrastructure through event-driven functions that auto-scale, with pay-per-use billing and zero server maintenance.",
  "explanation": "## Concept Overview\nServerless computing is a cloud execution model where providers manage infrastructure, scaling, and resource allocation automatically. Developers focus solely on business logic through functions triggered by events.\n\n## Implementation\nServerless platforms use container-based execution environments that spin up on demand:\n\n```javascript\n// AWS Lambda example\nexports.handler = async (event) => {\n  const { action, data } = JSON.parse(event.body);\n  \n  switch(action) {\n    case 'process':\n      return await processData(data);\n    case 'validate':\n      return await validateInput(data);\n    default:\n      throw new Error('Unsupported action');\n  }\n};\n```\n\nKey execution characteristics:\n- **Cold Starts**: Initial invocation latency (100-3000ms)\n- **Stateless**: Each execution is independent\n- **Resource Limits**: Memory (128-3008MB), duration (max 15 minutes)\n- **Auto-scaling**: Concurrent instances based on request volume\n\n## Trade-offs\n\n**Pros:**\n- Zero operational overhead\n- Cost-effective for sporadic workloads\n- Built-in high availability and fault tolerance\n- Automatic scaling from 0 to thousands\n\n**Cons:**\n- Cold start latency\n- Vendor lock-in\n- Limited execution time and resources\n- Debugging complexity in distributed environments\n\n**When to use:**\n- API endpoints with unpredictable traffic\n- Data processing pipelines\n- Scheduled tasks and cron jobs\n- Real-time file processing\n\n## Common Pitfalls\n\n1. **Ignoring Cold Starts**: Not implementing provisioned concurrency for latency-sensitive applications\n\n2. **Stateful Anti-patterns**: Storing local data between invocations\n```javascript\n// BAD - stateful approach\nlet counter = 0;\nexports.handler = async (event) => {\n  counter++; // Lost between invocations\n  return { count: counter };\n};\n\n// GOOD - stateless with external storage\nexports.handler = async (event) => {\n  const currentCount = await getCounterFromDB();\n  await updateCounterInDB(currentCount + 1);\n  return { count: currentCount + 1 };\n};\n```\n\n3. **Timeout Misconfiguration**: Not setting appropriate timeouts for external service calls\n\n4. **Resource Over-provisioning**: Allocating excessive memory, increasing costs unnecessarily\n\n5. **Missing Error Handling**: Not implementing retry logic for transient failures",
  "difficulty": "beginner",
  "tags": [
    "serverless",
    "lambda"
  ],
  "lastUpdated": "2025-12-15T06:36:14.867Z",
  "diagram": "flowchart TD\n    A[Client Request] --> B[API Gateway]\n    B --> C{Event Trigger}\n    C -->|HTTP| D[HTTP Function]\n    C -->|File Upload| E[Storage Function]\n    C -->|Database Change| F[DB Trigger Function]\n    \n    D --> G[Function Container]\n    E --> G\n    F --> G\n    \n    G --> H[Business Logic]\n    H --> I[External Services]\n    H --> J[Database]\n    \n    I --> K[Response]\n    J --> K\n    K --> L[Client]\n    \n    M[Auto Scaling] --> G\n    N[Monitoring] --> O[Logs & Metrics]\n    G --> N\n    \n    style G fill:#e1f5fe\n    style M fill:#f3e5f5\n    style N fill:#fff3e0"
}