{
  "id": "sy-151",
  "question": "Design a rate limiting API for a multi-tenant SaaS platform where different customers have different rate limits (free: 100 req/hour, premium: 1000 req/hour, enterprise: custom). How would you design the API endpoints and data structures to efficiently track and enforce these limits?",
  "answer": "Use token bucket algorithm with Redis, API key middleware, and tiered limit configs stored in DB with in-memory cache for fast lookups.",
  "explanation": "## Rate Limiting API Design\n\n### Core Components\n\n**1. API Structure**\n```\nPOST /api/v1/ratelimit/check\nGET /api/v1/ratelimit/status/:apiKey\nPOST /api/v1/ratelimit/reset/:apiKey (admin)\n```\n\n**2. Data Structures**\n- **Redis**: Store token buckets with TTL\n  - Key: `ratelimit:{tenant_id}:{window}`\n  - Value: `{tokens_remaining, last_refill_time}`\n- **Database**: Tenant configurations\n  - `tenants` table: `{id, tier, custom_limit, window_seconds}`\n- **In-Memory Cache**: Hot tenant limits (LRU cache)\n\n**3. Token Bucket Algorithm**\n- Each request consumes 1 token\n- Tokens refill at configured rate\n- Bucket capacity = tier limit\n- Use Redis INCR/DECR for atomic operations\n\n**4. Implementation Flow**\n1. Extract API key from request header\n2. Check in-memory cache for tenant tier\n3. If miss, query DB and cache result\n4. Check Redis for current token count\n5. If tokens available: decrement and allow\n6. If depleted: return 429 with Retry-After header\n\n**5. Response Headers**\n```\nX-RateLimit-Limit: 1000\nX-RateLimit-Remaining: 847\nX-RateLimit-Reset: 1640000000\nRetry-After: 3600 (if rate limited)\n```\n\n**6. Scalability Considerations**\n- Use Redis Cluster for horizontal scaling\n- Implement sliding window for smoother limits\n- Add circuit breaker for Redis failures (fail open)\n- Use distributed rate limiting for multi-region\n\n**7. Edge Cases**\n- Burst allowance for enterprise customers\n- Grace period for tier upgrades\n- Rate limit exemptions for health checks",
  "diagram": "graph TD\n    A[Client Request] --> B[API Gateway]\n    B --> C{Extract API Key}\n    C --> D[Check Memory Cache]\n    D --> E{Cache Hit?}\n    E -->|No| F[Query DB for Tier]\n    F --> G[Cache Tier Config]\n    G --> H[Check Redis Token Bucket]\n    E -->|Yes| H\n    H --> I{Tokens Available?}\n    I -->|Yes| J[Decrement Token]\n    J --> K[Allow Request]\n    K --> L[Add Rate Limit Headers]\n    I -->|No| M[Return 429 Too Many Requests]\n    M --> N[Add Retry-After Header]\n    L --> O[Forward to Backend]\n    \n    subgraph Redis\n    H\n    J\n    end\n    \n    subgraph Database\n    F\n    end\n    \n    subgraph Memory Cache\n    D\n    G\n    end",
  "difficulty": "intermediate",
  "tags": [
    "api",
    "rest"
  ],
  "lastUpdated": "2025-12-13T01:07:37.875Z"
}