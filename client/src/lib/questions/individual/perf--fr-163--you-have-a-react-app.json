{
  "id": "fr-163",
  "question": "You have a React app rendering a list of 10,000 items. Each item has a complex component with multiple child components. The list scrolls slowly and feels janky. Describe three different optimization strategies you would apply, explaining when to use each approach and their trade-offs.",
  "answer": "Use virtualization (react-window), memoization (React.memo/useMemo), and code splitting. Each targets different bottlenecks.",
  "explanation": "## Three Core Optimization Strategies\n\n### 1. Virtualization (react-window/react-virtual)\n\n**When to use:** Large lists where only a few items are visible at once\n\n**How it works:**\n- Only renders items currently in viewport + small buffer\n- Dynamically mounts/unmounts components as user scrolls\n- Reduces DOM nodes from 10,000 to ~20-30\n\n```javascript\nimport { FixedSizeList } from 'react-window';\n\nconst VirtualList = () => (\n  <FixedSizeList\n    height={600}\n    itemCount={10000}\n    itemSize={50}\n    width=\"100%\"\n  >\n    {({ index, style }) => (\n      <div style={style}>Item {index}</div>\n    )}\n  </FixedSizeList>\n);\n```\n\n**Trade-offs:**\n- ✅ Massive performance gain for long lists\n- ✅ Constant memory usage regardless of list size\n- ❌ Requires fixed/estimated item heights\n- ❌ Breaks native browser features (find-in-page, accessibility)\n\n### 2. Memoization (React.memo, useMemo, useCallback)\n\n**When to use:** Components re-rendering unnecessarily with same props\n\n**How it works:**\n- `React.memo`: Prevents re-render if props haven't changed\n- `useMemo`: Caches expensive computations\n- `useCallback`: Stabilizes function references\n\n```javascript\nconst ListItem = React.memo(({ item, onDelete }) => {\n  const formattedData = useMemo(\n    () => expensiveFormat(item.data),\n    [item.data]\n  );\n  \n  return <div onClick={onDelete}>{formattedData}</div>;\n});\n\nconst List = () => {\n  const handleDelete = useCallback((id) => {\n    deleteItem(id);\n  }, []);\n  \n  return items.map(item => (\n    <ListItem key={item.id} item={item} onDelete={handleDelete} />\n  ));\n};\n```\n\n**Trade-offs:**\n- ✅ Prevents wasted renders\n- ✅ Easy to implement incrementally\n- ❌ Adds memory overhead for memoization\n- ❌ Shallow comparison can miss deep object changes\n- ❌ Overuse can hurt performance (comparison cost)\n\n### 3. Code Splitting & Lazy Loading\n\n**When to use:** Heavy components not immediately needed\n\n**How it works:**\n- Split bundle into chunks\n- Load components on-demand\n- Reduce initial JavaScript payload\n\n```javascript\nconst HeavyChart = lazy(() => import('./HeavyChart'));\n\nconst ListItem = ({ item }) => (\n  <div>\n    <h3>{item.title}</h3>\n    <Suspense fallback={<Spinner />}>\n      {item.showChart && <HeavyChart data={item.data} />}\n    </Suspense>\n  </div>\n);\n```\n\n**Trade-offs:**\n- ✅ Faster initial load\n- ✅ Reduces main bundle size\n- ❌ Network delay when loading chunks\n- ❌ Requires loading states\n- ❌ Can cause layout shifts\n\n## Decision Matrix\n\n| Scenario | Best Strategy |\n|----------|---------------|\n| 10k+ simple items | Virtualization |\n| Complex items, frequent parent updates | Memoization |\n| Heavy dependencies per item | Code splitting |\n| All of the above | Combine all three |\n\n## Measuring Impact\n\nUse React DevTools Profiler to identify:\n- **Render duration**: How long each component takes\n- **Render frequency**: How often components re-render\n- **Wasted renders**: Components rendering with same props",
  "diagram": "graph TD\n    A[10k Items List Problem] --> B{Identify Bottleneck}\n    B --> C[Too Many DOM Nodes]\n    B --> D[Unnecessary Re-renders]\n    B --> E[Large Bundle Size]\n    \n    C --> F[Virtualization]\n    F --> F1[Render only visible items]\n    F1 --> F2[~30 DOM nodes vs 10k]\n    \n    D --> G[Memoization]\n    G --> G1[React.memo on ListItem]\n    G1 --> G2[useMemo for computations]\n    G2 --> G3[useCallback for handlers]\n    \n    E --> H[Code Splitting]\n    H --> H1[Lazy load heavy components]\n    H1 --> H2[Reduce initial bundle]\n    \n    F2 --> I[Optimized App]\n    G3 --> I\n    H2 --> I\n    \n    style C fill:#ff6b6b\n    style D fill:#ffd93d\n    style E fill:#6bcf7f\n    style I fill:#4ecdc4",
  "difficulty": "advanced",
  "tags": [
    "perf",
    "optimization"
  ],
  "lastUpdated": "2025-12-13T03:04:11.191Z"
}