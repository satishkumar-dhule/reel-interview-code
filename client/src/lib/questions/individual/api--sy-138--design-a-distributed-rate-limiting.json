{
  "id": "sy-138",
  "question": "Design a distributed rate limiting system that can handle 10M requests per minute across 100+ microservices with different rate limit policies per service and API key.",
  "answer": "Use token bucket algorithm with Redis cluster, local caching, and hierarchical rate limiting (global + per-service + per-key).",
  "explanation": "# Distributed Rate Limiting System Design\n\n## Core Requirements\n- 10M requests/minute throughput\n- Multiple rate limit policies per service\n- Per-API key limits\n- 99.9% availability\n- Sub-10ms latency\n\n## Architecture Components\n\n### 1. Rate Limiting Engine\n- **Token Bucket Algorithm**: Flexible burst handling\n- **Sliding Window**: Time-based accuracy\n- **Policy Engine**: Dynamic rule evaluation\n\n### 2. Storage Layer\n- **Redis Cluster**: Primary counter storage\n- **Local Cache**: LRU for frequently accessed keys\n- **Persistent Storage**: PostgreSQL for policy configuration\n\n### 3. Distribution Strategy\n- **Consistent Hashing**: Even key distribution\n- **Replication**: Multi-master Redis setup\n- **Sharding**: Key-based partitioning\n\n## Key Design Patterns\n\n### Hierarchical Rate Limiting\n1. **Global Limits**: Platform-wide protection\n2. **Service Limits**: Per-microservice constraints\n3. **API Key Limits**: User-specific restrictions\n\n### Performance Optimizations\n- **Batch Processing**: Redis MGET/MSET operations\n- **Async Updates**: Fire-and-forget counter increments\n- **Pre-aggregation**: Local batching before sync\n\n### Failure Handling\n- **Graceful Degradation**: Fallback to local-only limiting\n- **Circuit Breaker**: Fail-fast for Redis outages\n- **Rate Limit Escalation**: Progressive restriction\n\n## Implementation Considerations\n\n### Synchronization\n- **Atomic Operations**: Redis INCR with expiration\n- **Clock Drift**: NTP synchronization\n- **Consistent Window**: Aligned time boundaries\n\n### Scalability\n- **Horizontal Scaling**: Add Redis nodes\n- **Geographic Distribution**: Edge caching\n- **Load Distribution**: Smart client routing\n\n### Monitoring & Observability\n- **Real-time Metrics**: Prometheus integration\n- **Alerting**: Rate limit breach detection\n- **Audit Trail**: Policy change tracking",
  "diagram": "graph TD\n    A[Client Request] --> B[API Gateway]\n    B --> C[Rate Limiter Service]\n    C --> D{Local Cache Check}\n    D -->|Hit| E[Return Decision]\n    D -->|Miss| F[Redis Cluster]\n    F --> G[Policy Engine]\n    G --> H[Rate Limit Algorithm]\n    H --> I[Update Local Cache]\n    I --> E\n    E --> J{Allow?}\n    J -->|Yes| K[Forward to Service]\n    J -->|No| L[Return 429]\n    \n    subgraph \"Redis Cluster\"\n        F1[Shard 1]\n        F2[Shard 2]\n        F3[Shard N]\n    end\n    \n    subgraph \"Policy Store\"\n        G1[Global Policies]\n        G2[Service Policies]\n        G3[API Key Policies]\n    end\n    \n    G --> G1\n    G --> G2\n    G --> G3",
  "difficulty": "advanced",
  "tags": [
    "api",
    "rest"
  ],
  "lastUpdated": "2025-12-12T09:36:34.140Z"
}