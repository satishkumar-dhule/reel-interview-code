[
  {
    "id": "al-1",
    "question": "When would you use a Linked List over an Array?",
    "answer": "Linked Lists excel at insertions/deletions, Arrays excel at random access.",
    "explanation": "**Array**:\n- Access: O(1) (Direct memory address)\n- Insert/Delete: O(n) (Shift elements)\n- Memory: Contiguous\n\n**Linked List**:\n- Access: O(n) (Traversal)\n- Insert/Delete: O(1) (Change pointer - if you have the node)\n- Memory: Scattered (Heap)\n\n**Use List when**: Implementing Queues, Stacks, or when memory is fragmented.",
    "tags": [
      "struct",
      "comparison",
      "basics"
    ],
    "difficulty": "beginner",
    "channel": "algorithms",
    "subChannel": "data-structures",
    "diagram": "\ngraph LR\n    subgraph Array\n    A1[0] --- A2[1] --- A3[2] --- A4[3]\n    end\n    subgraph LinkedList\n    L1[Node] --> L2[Node] --> L3[Node]\n    end\n",
    "lastUpdated": "2025-12-12T09:07:04.185Z"
  },
  {
    "id": "al-2",
    "question": "Explain QuickSort vs MergeSort. Which is better?",
    "answer": "QuickSort is generally faster in practice (cache locality) but unstable. MergeSort is stable but uses O(n) space.",
    "explanation": "**QuickSort**:\n- Avg: O(n log n), Worst: O(n^2) (bad pivot).\n- Space: O(log n) stack.\n- **In-place**.\n\n**MergeSort**:\n- Always O(n log n).\n- Space: O(n) (aux array).\n- **Stable** (preserves order of equals).\n\n**Verdict**: Arrays -> QuickSort. Linked Lists -> MergeSort.",
    "tags": [
      "sort",
      "recursion",
      "complexity"
    ],
    "difficulty": "intermediate",
    "channel": "algorithms",
    "subChannel": "sorting",
    "diagram": "\ngraph TD\n    A[Array] --> P{Pick Pivot}\n    P --> L[Left < Pivot]\n    P --> R[Right > Pivot]\n    L --> Sort1[Recurse]\n    R --> Sort2[Recurse]\n",
    "lastUpdated": "2025-12-12T09:07:04.185Z"
  },
  {
    "id": "al-3",
    "question": "What is Dynamic Programming? How is it different from Recursion?",
    "answer": "DP is Recursion + Optimization (Memoization/Tabulation).",
    "explanation": "Recursion solves subproblems blindly (potentially repeating work).\n\n**DP** stores the result of subproblems so you never solve the same problem twice.\n\n**Example**: Fibonacci.\n- Recursion: `fib(n-1) + fib(n-2)` -> O(2^n)\n- DP: Store `fib` array -> O(n)\n\n**Two Approaches**:\n1. Top-Down (Memoization)\n2. Bottom-Up (Tabulation)",
    "tags": [
      "dp",
      "optimization",
      "theory"
    ],
    "difficulty": "advanced",
    "channel": "algorithms",
    "subChannel": "dynamic-programming",
    "diagram": "\ngraph TD\n    P[Problem] --> S1[Subproblem 1]\n    P --> S2[Subproblem 2]\n    S1 --> C[(Cache)]\n    S2 --> C\n    C --> R[Result]\n",
    "lastUpdated": "2025-12-12T09:07:04.185Z"
  },
  {
    "id": "al-152",
    "question": "You have a staircase with n steps. You can climb 1, 2, or 3 steps at a time. How many distinct ways can you reach the top? Implement a solution with O(n) time and O(1) space complexity.",
    "answer": "Use DP with 3 variables tracking last 3 positions. dp[i] = dp[i-1] + dp[i-2] + dp[i-3]. Base: dp[0]=1, dp[1]=1, dp[2]=2",
    "explanation": "## Approach\n\nThis is a classic dynamic programming problem similar to climbing stairs, but with three possible steps instead of two.\n\n## Solution\n\n### Recurrence Relation\n\nFor each step `i`, the number of ways to reach it is the sum of ways to reach the previous three steps:\n\n```\ndp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n```\n\n### Base Cases\n\n- `dp[0] = 1` (one way to stay at ground)\n- `dp[1] = 1` (one step)\n- `dp[2] = 2` (1+1 or 2)\n\n### Space Optimization\n\nInstead of maintaining an array of size n, we only need three variables to track the last three positions:\n\n```python\ndef climbStairs(n):\n    if n <= 2:\n        return n if n > 0 else 1\n    \n    a, b, c = 1, 1, 2  # dp[0], dp[1], dp[2]\n    \n    for i in range(3, n + 1):\n        current = a + b + c\n        a, b, c = b, c, current\n    \n    return c\n```\n\n## Complexity\n\n- **Time**: O(n) - single pass through n steps\n- **Space**: O(1) - only three variables used\n\n## Example\n\nFor n=4:\n- dp[3] = dp[2] + dp[1] + dp[0] = 2 + 1 + 1 = 4\n- dp[4] = dp[3] + dp[2] + dp[1] = 4 + 2 + 1 = 7\n\nThere are 7 distinct ways to climb 4 steps.",
    "tags": [
      "dp",
      "optimization"
    ],
    "difficulty": "intermediate",
    "channel": "algorithms",
    "subChannel": "dynamic-programming",
    "diagram": "graph TD\n    A[\"n=4 (target)\"] --> B[\"n=3 (4 ways)\"]\n    A --> C[\"n=2 (2 ways)\"]\n    A --> D[\"n=1 (1 way)\"]\n    B --> E[\"n=2 (2 ways)\"]\n    B --> F[\"n=1 (1 way)\"]\n    B --> G[\"n=0 (1 way)\"]\n    C --> H[\"n=1 (1 way)\"]\n    C --> I[\"n=0 (1 way)\"]\n    D --> J[\"n=0 (1 way)\"]\n    \n    style A fill:#ff6b6b\n    style B fill:#4ecdc4\n    style C fill:#4ecdc4\n    style D fill:#4ecdc4\n    style E fill:#95e1d3\n    style F fill:#95e1d3\n    style G fill:#95e1d3\n    style H fill:#95e1d3\n    style I fill:#95e1d3\n    style J fill:#95e1d3",
    "lastUpdated": "2025-12-13T01:07:52.426Z"
  },
  {
    "id": "al-163",
    "question": "You have an array where each element appears twice except one element that appears once. Sort the array in O(n) time without using extra space for sorting. How would you approach this?",
    "answer": "Use XOR to find the unique element first, then partition array around it using modified counting sort with bit manipulation.",
    "explanation": "## Approach\n\nThis problem combines bit manipulation with in-place partitioning:\n\n### Step 1: Find the Unique Element\nUse XOR operation on all elements. Since `a ^ a = 0` and `a ^ 0 = a`, all paired elements cancel out, leaving only the unique element.\n\n```javascript\nlet unique = 0;\nfor (let num of arr) {\n  unique ^= num;\n}\n```\n\n### Step 2: Partition Around Unique Element\nUse three-way partitioning (similar to Dutch National Flag):\n- Elements less than unique go left\n- Unique element in middle\n- Elements greater than unique go right\n\n```javascript\nlet low = 0, mid = 0, high = arr.length - 1;\nwhile (mid <= high) {\n  if (arr[mid] < unique) {\n    [arr[low], arr[mid]] = [arr[mid], arr[low]];\n    low++; mid++;\n  } else if (arr[mid] > unique) {\n    [arr[mid], arr[high]] = [arr[high], arr[mid]];\n    high--;\n  } else {\n    mid++;\n  }\n}\n```\n\n### Step 3: Sort Pairs\nWithin each partition, pairs are already together. Use counting sort or simply swap pairs into position.\n\n**Time Complexity:** O(n)\n**Space Complexity:** O(1)",
    "tags": [
      "sort",
      "complexity"
    ],
    "difficulty": "intermediate",
    "channel": "algorithms",
    "subChannel": "sorting",
    "diagram": "graph TD\n    A[Start: Unsorted Array] --> B[XOR all elements]\n    B --> C[Find unique element]\n    C --> D[Three-way partition]\n    D --> E[Elements < unique]\n    D --> F[Unique element]\n    D --> G[Elements > unique]\n    E --> H[Sort pairs in left partition]\n    G --> I[Sort pairs in right partition]\n    H --> J[Combine: Left + Unique + Right]\n    I --> J\n    J --> K[Sorted Array]\n    \n    style C fill:#90EE90\n    style D fill:#FFB6C1\n    style K fill:#87CEEB",
    "lastUpdated": "2025-12-13T16:57:00.393Z"
  },
  {
    "id": "al-164",
    "question": "Count Ways to Reach Target Sum with Array Elements",
    "answer": "Use DP with subset sum approach",
    "explanation": "This is a variation of subset sum where we count ways to reach target using array elements",
    "tags": [
      "dp",
      "optimization"
    ],
    "difficulty": "intermediate",
    "channel": "algorithms",
    "subChannel": "dynamic-programming",
    "diagram": "graph TD\n    A[Start] --> B[DP Array]\n    B --> C[Iterate Elements]\n    C --> D[Update DP]\n    D --> E[Return Count]",
    "lastUpdated": "2025-12-13T16:59:18.824Z"
  },
  {
    "id": "al-165",
    "question": "Implement a Trie data structure for efficient prefix search. What are its advantages over a hash map?",
    "answer": "Trie provides O(k) prefix search, space-efficient for common prefixes.",
    "explanation": "## Trie Structure\n\nA Trie (prefix tree) stores strings character by character, sharing common prefixes.\n\n```python\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self,word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end = True\n```\n\n## Advantages over Hash Map\n\n**Prefix Search**: Find all words with prefix in O(k) where k = prefix length\n**Space Efficiency**: Common prefixes shared (e.g., 'app', 'apple', 'application')\n**Sorted Output**: Lexicographic order traversal\n**No Collisions**: Unlike hash maps\n\n## Use Cases\n- Autocomplete systems\n- Spell checkers\n- IP routing tables\n- Dictionary implementations",
    "tags": [
      "data-structure",
      "string",
      "prefix"
    ],
    "difficulty": "intermediate",
    "channel": "layers",
    "subChannel": "data-structures",
    "diagram": "graph TD\n    A[Root] --> A1[a] --> P1[pp] --> P2[p] --> P3[l] --> E1[apple]\n    A --> A2[a] --> P4[pp] --> P5[l] --> E2[apply]\n    A --> A3[a] --> P6[pp] --> P7[l] --> E3[application]\n    A --> A4[a] --> P8[pp] --> P9[l] --> E4[approach]\n    \n    style A fill:#FF6B6B\n    style E1 fill:#4ECDC4\n    style E2 fill:#4ECDC4\n    style E3 fill:#4ECDC4\n    style E4 fill:#95E1D3",
    "lastUpdated": "2025-12-13T17:01:42.123Z"
  },
  {
    "id": "al-165",
    "question": "Implement a Trie data structure for efficient prefix search. What are its advantages over a hash map?",
    "answer": "Trie provides O(k) prefix search, space-efficient for common prefixes.",
    "explanation": "## Trie Structure\n\nA Trie (prefix tree) stores strings character by character, sharing common prefixes.\n\n```python\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    \n    def insert(self,word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end = True\n```\n\n## Advantages over Hash Map\n\n**Prefix Search**: Find all words with prefix in O(k) where k = prefix length\n**Space Efficiency**: Common prefixes shared (e.g., 'app', 'apple', 'application')\n**Sorted Output**: Lexicographic order traversal\n**No Collisions**: Unlike hash maps\n\n## Use Cases\n- Autocomplete systems\n- Spell checkers\n- IP routing tables\n- Dictionary implementations",
    "tags": [
      "struct",
      "basics"
    ],
    "difficulty": "intermediate",
    "channel": "algorithms",
    "subChannel": "data-structures",
    "diagram": "graph TD\n    A[Root] --> A1[a] --> P1[pp] --> P2[p] --> P3[l] --> E1[apple]\n    A --> A2[a] --> P4[pp] --> P5[l] --> E2[apply]\n    A --> A3[a] --> P6[p] --> P7[l] --> E3[application]\n    A --> A4[a] --> P8[pp] --> P9[l] --> E4[approach]\n    \n    style A fill:#FF6B6B\n    style E1 fill:#4ECDC4\n    style E2 fill:#4ECDC4\n    style E3 fill:#4ECDC4\n    style E4 fill:#95E1D3",
    "lastUpdated": "2025-12-13T16:59:48.670Z"
  },
  {
    "id": "al-166",
    "question": "Given a string, find the minimum number of insertions and deletions to make it a palindrome. Each insertion costs 2, each deletion costs 1.",
    "answer": "Use DP with states (i,j) representing substring s[i..j] and compute min operations recursively.",
    "explanation": "This is a variation of the classic edit distance problem. We use DP where dp[i][j] = min operations to make substring s[i..j] a palindrome. If s[i] == s[j], dp[i][j] = dp[i+1][j-1] = 1 + min(dp[i+1][j-1], dp[i][j-1] + 1, dp[i+1][j] + 2). Base cases: i >= j return 0. The answer is dp[0][n-1].",
    "tags": [
      "dp",
      "optimization"
    ],
    "difficulty": "intermediate",
    "channel": "algorithms",
    "subChannel": "dynamic-programming",
    "diagram": "graph TD\n    A[Start dp[i][j]] --> B{s[i] == s[j]}\n    B -->|Yes| C[dp[i+1][j-1]]\n    B -->|No| D[1 + min(dp[i+1][j-1], dp[i+1][j], dp[i][j-1])]\n    C --> E[Return dp[i][j]]\n    D --> E",
    "lastUpdated": "2025-12-13T16:59:58.522Z"
  },
  {
    "id": "al-167",
    "question": "Count ways to reach target sum using dice rolls 1-6",
    "answer": "DP where dp[i] = sum(dp[i-1] to i-6)",
    "explanation": "Use DP where dp[i] = sum(dp[i-1] to i-6)",
    "tags": [
      "dp",
      "optimization"
    ],
    "difficulty": "intermediate",
    "channel": "algorithms",
    "subChannel": "dynamic-programming",
    "diagram": "graph TD; A[0]=1; for i=1 to target; dp[i]=sum(dp[i-1] to i-6)",
    "lastUpdated": "2025-12-13T17:00:15.427Z"
  },
  {
    "id": "al-170",
    "question": "Given an array of integers where each element represents the maximum number of steps you can jump forward from that position, find the minimum number of jumps needed to reach the last index. If it's impossible, return -1. You can only move forward.",
    "answer": "Use greedy approach tracking current range and furthest reachable position in O(n) time.",
    "explanation": "This is a variation of the Jump Game II problem. The optimal solution uses a greedy approach:\n\n1. Keep track of the current range (end) where we can reach with the current number of jumps\n2. Track the furthest position we can reach within the next range (furthest)\n3. When we reach the end of the current range, we must make another jump\n4. Update the range to the furthest position we found\n\nTime complexity: O(n), Space complexity: O(1)\n\nThe key insight is that we don't need to explore all possible paths - we just need to know the furthest we can reach within each jump range.",
    "tags": [
      "dp",
      "optimization"
    ],
    "difficulty": "advanced",
    "channel": "algorithms",
    "subChannel": "dynamic-programming",
    "diagram": "graph TD\n    A[Start at index 0] --> B[Initialize jumps=0, end=0, furthest=0]\n    B --> C[Iterate through array]\n    C --> D{Reached end of current range?}\n    D -->|Yes| E[Increment jumps, set end=furthest]\n    D -->|No| F[Update furthest = max(furthest, i + nums[i])]\n    E --> F\n    F --> G{Can reach last index?}\n    G -->|Yes| H[Return jumps]\n    G -->|No| I[Continue to next position]\n    I --> C\n    H --> J[End]\n    C --> K{i >= n-1?}\n    K -->|Yes| H\n    K -->|No| D",
    "lastUpdated": "2025-12-14T01:17:23.338Z"
  }
]