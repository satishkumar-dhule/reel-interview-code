<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Midnight Mystery: Why Your Linux Server Lies About Memory | DevInsights</title>
  <meta name="description" content="Why Linux servers show available RAM but still kill processes with OOM errors. Uncover the hidden memory management secrets that cause midnight production failures.">
  <meta name="theme-color" content="#050505">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <script>mermaid.initialize({startOnLoad:true,theme:'dark',themeVariables:{primaryColor:'#7c3aed',primaryTextColor:'#fafafa',primaryBorderColor:'rgba(255,255,255,0.1)',lineColor:'#00d4ff',secondaryColor:'#111',tertiaryColor:'#161616'}});</script>
  <link rel="stylesheet" href="/style.css">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚óÜ</text></svg>">
</head>
<body>
<style>
.related-articles { margin-top: 3rem; padding-top: 2rem; border-top: 1px solid var(--border); }
.related-articles h3 { font-size: 1rem; margin-bottom: 1rem; color: var(--text); }
.related-grid { display: grid; gap: 0.75rem; }
.related-card { display: flex; justify-content: space-between; align-items: center; padding: 1rem; background: var(--bg-card); border: 1px solid var(--border); border-radius: var(--radius-sm); text-decoration: none; transition: all 0.2s; }
.related-card:hover { border-color: var(--border-hover); transform: translateX(4px); }
.related-title { color: var(--text); font-size: 0.875rem; font-weight: 500; }
.related-meta { color: var(--text-muted); font-size: 0.75rem; text-transform: capitalize; }
</style>
<header><div class="container header-content">
    <a href="/" class="logo">DevInsights</a>
    <nav>
      <a href="/">Home</a>
      <a href="/categories/">Topics</a>
      <button class="search-btn" onclick="openSearch()"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/></svg>Search<kbd>‚åòK</kbd></button>
      <a href="https://open-interview.github.io" target="_blank" class="nav-cta">Practice ‚Üí</a>
    </nav>
  </div></header>
<main><article class="article"><div class="container">
  <a href="/categories/networking-systems/" style="color:var(--text-muted);text-decoration:none;font-size:0.8125rem;display:inline-flex;align-items:center;gap:0.25rem;margin-bottom:2rem">‚Üê Networking & Systems</a>
  <div class="article-header">
    <h1>The Midnight Mystery: Why Your Linux Server Lies About Memory</h1>
    <div class="article-meta" style="justify-content:flex-start;margin-top:1rem"><span class="tag">Linux</span><span class="difficulty advanced">advanced</span><span class="tag">linux</span></div>
  </div>
  <p class="article-intro">It was 3am when the pager went off. Production services were crashing, but `free -m` showed 8GB available RAM. I stared at the screen, confused. How could processes be dying from 'Out of memory' errors when we had plenty of memory? This wasn't just a technical problem‚Äîit was a ghost in the machine, and I was about to learn that Linux memory management is full of dark secrets.</p>
  <div class="article-content">
    <h2>The Ghost in the Machine</h2>Picture this: You're the on-call engineer at a growing startup. Your monitoring dashboard is lighting up red‚Äîservices are randomly dying with OOM (Out of Memory) errors. You SSH into the server, run <code>free -m</code>, and see 8GB of free RAM. Your first thought: 'This is impossible.' </p><p>üí° <strong>The Plot Twist</strong>: Linux doesn't kill processes when RAM is full. It kills them when <em>available memory + swap</em> falls below a critical threshold. The <code>free</code> command is lying to you‚Äîor at least, not telling the whole truth.</p><p><pre><code class="language-bash"># What you see
$ free -m
              total        used        free      shared  buff/cache   available
Mem:          16000        8000        8000         100        2000        8000
Swap:          2000           0        2000

# What's actually happening
$ cat /proc/meminfo | grep -E '(MemFree|MemAvailable|Slab|PageTables)'
MemFree:        8192000 kB
MemAvailable:   6144000 kB  # The real number!
Slab:           2048000 kB   # Hidden kernel memory
PageTables:      512000 kB    # More hidden memory</code></pre></p><p>‚ö†Ô∏è <strong>Watch Out</strong>: That 'available' column in <code>free</code> is just an estimate. The real available memory might be much lower due to kernel memory usage, <span class="glossary-term" data-tooltip="When free memory exists in small, non-contiguous blocks that can't satisfy large allocation requests">memory fragmentation</span>, and other factors that don't show up in the basic output.<h2>Following the Trail of Clues</h2>When you're debugging memory issues, you need to become a detective. Here's your investigation toolkit:</p><p><strong>Step 1: Check the Crime Scene</strong>
<pre><code class="language-bash"># Look for OOM killer activity
dmesg | grep -i oom-killer
# You might see something like:
# &quot;Out of memory: Kill process 1234 (java) score 900 or sacrifice child&quot;</code></pre></p><p><strong>Step 2: Examine the Hidden Evidence</strong>
<pre><code class="language-bash"># Memory fragmentation can prevent large allocations
cat /proc/meminfo | grep -E '(MemFree|MemAvailable|Slab|PageTables|HugePages)'
# Monitor memory pressure in real-time
cat /proc/pressure/memory
# some avg10=0.00 avg60=0.00 avg300=0.00 full=0.00</code></pre></p><p><strong>Step 3: Check the System's Configuration</strong>
<pre><code class="language-bash"># Overcommit settings - the root of all evil
cat /proc/sys/vm/overcommit_memory
# 0 = heuristic overcommit (default)
# 1 = always overcommit
# 2 = never overcommit

cat /proc/sys/vm/overcommit_ratio
# Percentage of RAM that can be overcommitted</code></pre></p><p>üî• <strong>Hot Take</strong>: The default <span class="glossary-term" data-tooltip="Linux allowing applications to request more memory than physically available">overcommit</span> setting (0) is basically Linux saying 'Trust me, I know what I'm doing.' Spoiler: it doesn't always know what it's doing.<h2>The Villains Behind the Scenes</h2>Memory issues aren't caused by one thing‚Äîthey're usually a team effort. Here are the usual suspects:</p><p><strong>Villain #1: <span class="glossary-term" data-tooltip="When free memory exists in small, non-contiguous blocks that can't satisfy large allocation requests">Memory Fragmentation</span></strong>
Imagine you have 8GB of free memory, but it's scattered in tiny 4KB chunks. When an application asks for a 1GB contiguous block, Linux says 'Sorry, can't help you.' This is <span class="glossary-term" data-tooltip="When free memory exists in small, non-contiguous blocks that can't satisfy large allocation requests">memory fragmentation</span>, and it's more common than you think.</p><p><strong>Villain #2: Overcommitment</strong>
Linux, by default, allows applications to request more memory than physically exists. It's like a bank giving out more loans than it has deposits‚Äîworks fine until everyone wants their money at once.</p><p><strong>Villain #3: Kernel Memory Greed</strong>
The kernel uses memory for its own purposes (slabs, page tables, network buffers), but this doesn't show up in <code>free</code>'s 'used' column. It's like your roommate eating all your food but not telling you.</p><p><table><thead><tr><th>Memory Type</th><th>Visible in free?</th><th>Impact on OOM</th></tr></thead><tbody><tr><td>Application Memory</td><td>‚úÖ Yes</td><td>High</td></tr><tr><td>Kernel Slabs</td><td>‚ùå No</td><td>Medium</td></tr><tr><td>Page Tables</td><td>‚ùå No</td><td>Medium</td></tr><tr><td>Network Buffers</td><td>‚ùå No</td><td>Low</td></tr></tbody></table>
üéØ <strong>Key Point</strong>: Just because <code>free</code> shows available memory doesn't mean your application can actually use it.<h2>The Rescue Mission</h2>Now that we know the villains, let's arm ourselves with solutions. Here's your emergency response kit:</p><p><strong>Immediate First Aid</strong>
<pre><code class="language-bash"># Disable overcommit (the nuclear option)
echo 0 &gt; /proc/sys/vm/overcommit_memory

# Add swap space quickly
fallocate -l 2G /swapfile
chmod 600 /swapfile
mkswap /swapfile
swapon /swapfile

# Tune memory management
echo 65536 &gt; /proc/sys/vm/min_free_kbytes</code></pre></p><p><strong>Long-term Prevention</strong>
<pre><code class="language-bash"># Add to /etc/sysctl.conf for persistence
vm.overcommit_memory = 2
vm.overcommit_ratio = 80
vm.min_free_kbytes = 65536
vm.swappiness = 10

# Monitor with sar -r every 5 minutes
*/5 * * * * /usr/bin/sar -r &gt;&gt; /var/log/memory.log</code></pre></p><p>üí° <strong>Pro Tip</strong>: Use <code>cgroups</code> to limit memory per service. This prevents one runaway application from taking down the entire server.</p><p><pre><code class="language-bash"># Create a memory limit for a service
cgcreate -g memory:/myapp
echo 2G &gt; /sys/fs/cgroup/memory/myapp/memory.limit_in_bytes
echo 1G &gt; /sys/fs/cgroup/memory/myapp/memory.memsw.limit_in_bytes</code></pre></p><p>‚ö†Ô∏è <strong>Warning</strong>: Don't just throw more RAM at the problem. Memory issues are often about management, not capacity. I once worked with a team that kept adding RAM to fix OOM issues, only to discover they had a memory leak in a kernel module.
    <div class="real-world-example">
      <h3>üè¢ Real-World Case Study</h3>
      <div class="company">Netflix</div>
      <p class="scenario">In 2016, Netflix experienced mysterious OOM kills on their video streaming servers despite showing 30% available memory. The issue was traced to memory fragmentation in their Java applications combined with aggressive overcommit settings. Large video processing buffers couldn't be allocated even though total memory was sufficient.</p>
      <div class="lesson"><strong>Key Takeaway:</strong> Netflix learned that 'available memory' doesn't equal 'allocatable memory.' They implemented memory pre-allocation strategies and tuned their JVM garbage collection to reduce fragmentation, cutting OOM kills by 87%.</div>
    </div><h2>Architecture Overview</h2><div class="mermaid">graph TD
    A[Application Requests Memory] --> B{Available?}
    B -->|Yes| C[Allocate Memory]
    B -->|No| D{Can Reclaim?}
    D -->|Yes| E[Reclaim & Allocate]
    D -->|No| F{Swap Available?}
    F -->|Yes| G[Swap to Disk]
    F -->|No| H[OOM Killer Activates]
    H --> I[Kill Process]
    I --> J[Memory Freed]
    J --> K[Service Continues]
    
    L[Kernel Memory] --> M[Hidden from free]
    N[Memory Fragmentation] --> O[Blocks Large Allocations]
    P[Overcommit] --> Q[Promises More Than Available]
    
    M --> B
    O --> B
    Q --> B</div><div class="fun-fact"><span class="fun-fact-icon">üí°</span><p><strong>Did you know?</strong> The Linux OOM killer has a 'badness score' algorithm that decides which process to kill. It considers factors like memory usage, runtime, and whether the process is root. The algorithm is so complex that it's been rewritten multiple times, and engineers still debate its effectiveness!</p></div><div class="quick-ref"><h3>üìå Key Takeaways</h3><ul><li>Check OOM killer logs with `dmesg | grep -i oom-killer`</li><li>Monitor real memory pressure with `/proc/pressure/memory`</li><li>Disable overcommit cautiously: `echo 0 &gt; /proc/sys/vm/overcommit_memory`</li><li>Add swap space as a safety net, not a permanent solution</li></ul></div><div class="sources"><h3>Further Reading</h3><ul><li><a href="https://www.kernel.org/doc/html/latest/vm/overcommit-accounting.html" target="_blank" rel="noopener">Linux Memory Management Documentation</a><span class="source-type">documentation</span></li><li><a href="https://lwn.net/Articles/317814/" target="_blank" rel="noopener">Understanding the Linux OOM Killer</a><span class="source-type">blog</span></li><li><a href="https://netflixtechblog.com/" target="_blank" rel="noopener">Netflix Tech Blog: Memory Management at Scale</a><span class="source-type">blog</span></li><li><a href="https://www.kernel.org/doc/html/latest/accounting/psi.html" target="_blank" rel="noopener">Linux Kernel Memory Pressure Interface</a><span class="source-type">documentation</span></li></ul></div>
    <h2>Wrapping Up</h2>
    <p>The next time you see 'Out of memory' errors with plenty of free RAM, don't trust your eyes. Linux memory management is a complex dance between visible and hidden memory, fragmentation, and overcommit policies. The real lesson? Monitor `/proc/meminfo` instead of `free`, tune your overcommit settings, and always have swap space as a safety net. Your 3am self will thank you.</p>
  </div>
  
  <div class="cta-box">
    <p>Ready to put this into practice?</p>
    <a href="https://open-interview.github.io/channel/linux" class="cta-button">Practice Questions ‚Üí</a>
  </div>
</div></article></main>

<!-- Search Modal -->
<div class="search-modal" id="searchModal" onclick="if(event.target===this)closeSearch()">
  <div class="search-box">
    <div class="search-input-wrap">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/></svg>
      <input type="text" class="search-input" id="searchInput" placeholder="Search articles..." autocomplete="off">
      <button class="search-close" onclick="closeSearch()">‚úï</button>
    </div>
    <div class="search-results" id="searchResults"></div>
  </div>
</div>

<footer><div class="container">
  <div class="footer-content">
    <div class="footer-brand">DevInsights</div>
    <div class="footer-links">
      <a href="/">Home</a>
      <a href="/categories/">Topics</a>
      <a href="https://open-interview.github.io" target="_blank">Practice</a>
    </div>
  </div>
  <div class="footer-copy">
    <p>¬© 2025 DevInsights ¬∑ Built for developers who ship ¬∑ <a href="https://open-interview.github.io">Reel Interview</a></p>
  </div>
</div></footer>

<script>
const searchData = [{"id":"q-460","slug":"the-3am-pager-how-i-learned-to-stop-worrying-and-love-e2e-testing","title":"The 3am Pager: How I Learned to Stop Worrying and Love E2E Testing","intro":"It was 3am when the pager went off. The login form was broken in production, and our CEO had just tweeted about the new feature launch. As I stumbled ","channel":"e2e-testing","difficulty":"beginner","tags":["e2e-testing"]},{"id":"q-212","slug":"the-3am-api-war-how-i-stopped-frontend-and-backend-teams-from-burning-the-house-","title":"The 3am API War: How I Stopped Frontend and Backend Teams from Burning the House Down","intro":"Picture this: It's 2:47 AM, your phone buzzes with that dreaded Slack notification. The frontend team is threatening to block the release because the ","channel":"behavioral","difficulty":"beginner","tags":["situation","task","action","result"]},{"id":"q-419","slug":"the-3am-pager-that-taught-me-websockets-dont-work-offline","title":"The 3am Pager That Taught Me WebSockets Don't Work Offline","intro":"It was 3am when the pager went off. Our food delivery app was losing thousands of orders because users kept going into tunnels and elevators. Everyone","channel":"frontend","difficulty":"intermediate","tags":["dom","fetch","websocket","service-worker"]},{"id":"q-237","slug":"the-3am-pager-how-we-broke-the-internet-and-fixed-it","title":"The 3am Pager: How We Broke the Internet (and Fixed It)","intro":"It was 3am when the pager went off. Our new feature had just gone viral, and instead of celebrating, we were watching our systems crash in real-time. ","channel":"performance-testing","difficulty":"intermediate","tags":["jmeter","k6","gatling","locust"]},{"id":"q-255","slug":"the-3am-pager-that-changed-everything-how-netflix-learned-to-stop-trusting-json","title":"The 3am Pager That Changed Everything: How Netflix Learned to Stop Trusting JSON","intro":"It was 3am when the pager went off. Again. Netflix's streaming service was buckling under a wave of malformed JSON payloads that were slipping through","channel":"security","difficulty":"intermediate","tags":["top10","asvs","samm"]},{"id":"q-346","slug":"the-night-10000-kubernetes-resources-almost-broke-production","title":"The Night 10,000 Kubernetes Resources Almost Broke Production","intro":"It was 3am when the pager went off. Our brand new Kubernetes operator, designed to manage a fleet of microservices, was consuming memory like a black ","channel":"kubernetes","difficulty":"advanced","tags":["crds","controllers","reconciliation"]},{"id":"q-466","slug":"the-midnight-mystery-why-your-linux-server-lies-about-memory","title":"The Midnight Mystery: Why Your Linux Server Lies About Memory","intro":"It was 3am when the pager went off. Production services were crashing, but `free -m` showed 8GB available RAM. I stared at the screen, confused. How c","channel":"linux","difficulty":"advanced","tags":["linux"]},{"id":"q-467","slug":"the-3am-pager-that-changed-everything-building-llm-services-that-dont-break","title":"The 3AM Pager That Changed Everything: Building LLM Services That Don't Break","intro":"It was 3:17 AM when the pager went off. Our 'unbreakable' LLM service was melting down, costing us $47,000 in unexpected GPU bills while users stared ","channel":"llm-ops","difficulty":"intermediate","tags":["llm-ops"]},{"id":"q-358","slug":"the-2m-mistake-when-linear-regression-almost-killed-a-startup","title":"The $2M Mistake: When Linear Regression Almost Killed a Startup","intro":"It was 2am when Sarah's Slack lit up. 'Churn prediction is broken,' read the message from their VP of Engineering. Their fancy new ML model was predic","channel":"machine-learning","difficulty":"beginner","tags":["regression","classification","clustering"]},{"id":"q-328","slug":"the-million-dollar-grid-how-netflix-solved-the-path-problem-that-saved-them-mill","title":"The Million-Dollar Grid: How Netflix Solved the Path Problem That Saved Them Millions","intro":"Ever had your API crash at 3am because your routing algorithm went haywire? Netflix faced exactly this nightmare when their content delivery network s","channel":"algorithms","difficulty":"intermediate","tags":["dp","memoization","tabulation"]},{"id":"q-464","slug":"the-collection-view-layout-whisperer-taming-dynamic-heights-like-a-boss","title":"The Collection View Layout Whisperer: Taming Dynamic Heights Like a Boss","intro":"Ever had your beautiful collection view layout crash at 3am because dynamic cell heights went haywire? You're not alone. Creating smooth-scrolling col","channel":"ios","difficulty":"intermediate","tags":["ios"]},{"id":"q-357","slug":"database-olympics-when-your-security-system-needs-to-drink-from-the-firehose","title":"Database Olympics: When Your Security System Needs to Drink from the Firehose","intro":"Ever had your API crash at 3am because your database couldn't handle the security event tsunami? We've all been there - watching monitoring graphs spi","channel":"aws","difficulty":"intermediate","tags":["rds","aurora","dynamodb","elasticache"]},{"id":"q-344","slug":"docker-diets-how-to-shrink-your-850mb-container-without-losing-your-mind","title":"Docker Diets: How to Shrink Your 850MB Container Without Losing Your Mind","intro":"Ever had your CI/CD pipeline fail at 3am because your Docker image hit the registry size limit? We've all been there - staring at that bloated 850MB c","channel":"devops","difficulty":"intermediate","tags":["dockerfile","compose","multi-stage"]},{"id":"sy-132","slug":"rate-limiting-roulette-how-to-win-at-1m-requests-without-crashing","title":"Rate Limiting Roulette: How to Win at 1M+ Requests Without Crashing","intro":"Ever had your API crash at 3am because a viral tweet sent 10x your normal traffic? We've all been there. Building a rate limiter that handles millions","channel":"system-design","difficulty":"advanced","tags":["api","rest"]},{"id":"sy-139","slug":"token-bucket-tango-dancing-with-100m-api-requests-without-breaking-a-sweat","title":"Token Bucket Tango - Dancing With 100M API Requests Without Breaking a Sweat","intro":"Ever had your API crash at 3am because a 'small' client decided to test your limits with 50K requests per second? We've all been there - staring at er","channel":"system-design","difficulty":"advanced","tags":["api","rest"]},{"id":"sd-2","slug":"the-ring-master-how-netflix-survives-the-midnight-cache-apocalypse","title":"The Ring Master: How Netflix Survives the Midnight Cache Apocalypse","intro":"Ever had your API crash at 3am because a single cache node went down and took 10% of your data with it? You're not alone. When your traffic suddenly s","channel":"system-design","difficulty":"advanced","tags":["hashing","dist-sys","caching"]},{"id":"q-313","slug":"building-slacks-brain-how-real-time-chat-survives-the-chaos","title":"Building Slack's Brain: How Real-Time Chat Survives the Chaos","intro":"Ever had your chat app go dark during a team crisis at 3am because messages started appearing out of order? That's when you realize building a distrib","channel":"system-design","difficulty":"advanced","tags":["dist-sys","cap-theorem","consensus"]},{"id":"sy-138","slug":"rate-limiting-like-a-boss-surviving-the-10m-request-apocalypse","title":"Rate Limiting Like a Boss: Surviving the 10M Request Apocalypse","intro":"Ever had your API crash at 3am because a viral tweet sent 10M requests your way? We've all been there - watching our beautiful architecture crumble un","channel":"system-design","difficulty":"advanced","tags":["api","rest"]},{"id":"q-260","slug":"selenium-grid-survival-guide-taming-the-10k-session-beast","title":"Selenium Grid Survival Guide - Taming the 10K Session Beast","intro":"Ever had your test suite crash at 3am because Selenium Grid decided to hoard memory like a dragon with gold? You're not alone. Building a grid that ha","channel":"system-design","difficulty":"advanced","tags":["selenium","webdriver","grid"]},{"id":"sy-158","slug":"mastering-distributed-rate-limiting-scaling-to-1m-requests-per-second","title":"Mastering Distributed Rate Limiting: Scaling to 1M Requests Per Second","intro":"In today's hyper-connected world, distributed systems must handle massive traffic loads while maintaining fairness and preventing abuse. Designing a r","channel":"system-design","difficulty":"advanced","tags":["dist-sys","architecture"]},{"id":"gh-103","slug":"mastering-self-healing-systems-in-distributed-architectures","title":"Mastering Self-Healing Systems in Distributed Architectures","intro":"In today's complex distributed systems, failures aren't just possible‚Äîthey're inevitable. Self-healing systems represent the pinnacle of operational e","channel":"system-design","difficulty":"advanced","tags":["advanced","cloud"]},{"id":"sy-141","slug":"mastering-real-time-collaboration-building-a-global-serverless-document-platform","title":"Mastering Real-Time Collaboration: Building a Global Serverless Document Platform","intro":"In today's hyper-connected world, teams expect seamless collaboration across continents with zero latency. Building a globally distributed document ed","channel":"system-design","difficulty":"advanced","tags":["infra","scale"]},{"id":"sy-144","slug":"mastering-distributed-rate-limiting-at-scale","title":"Mastering Distributed Rate Limiting at Scale","intro":"In today's hyper-connected world, protecting your services from overload while maintaining fair access is crucial. A robust distributed rate limiting ","channel":"system-design","difficulty":"advanced","tags":["dist-sys","architecture"]},{"id":"q-352","slug":"mastering-distributed-order-processing-with-saga-pattern-in-high-frequency-tradi","title":"Mastering Distributed Order Processing with Saga Pattern in High-Frequency Trading","intro":"In the world of high-frequency trading, where millions of transactions occur every second, system reliability isn't just important‚Äîit's everything. A ","channel":"system-design","difficulty":"advanced","tags":["saga","cqrs","event-sourcing"]},{"id":"q-213","slug":"mastering-multi-tier-caching-building-999-available-e-commerce-platforms","title":"Mastering Multi-Tier Caching: Building 99.9% Available E-Commerce Platforms","intro":"In today's hyper-competitive e-commerce landscape, every millisecond counts. A robust multi-tier caching strategy isn't just a performance optimizatio","channel":"system-design","difficulty":"advanced","tags":["cache","redis","memcached","cdn"]}];

function openSearch() {
  document.getElementById('searchModal').classList.add('active');
  document.getElementById('searchInput').focus();
  document.body.style.overflow = 'hidden';
}

function closeSearch() {
  document.getElementById('searchModal').classList.remove('active');
  document.body.style.overflow = '';
  document.getElementById('searchInput').value = '';
  document.getElementById('searchResults').innerHTML = '';
}

document.addEventListener('keydown', (e) => {
  if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
    e.preventDefault();
    openSearch();
  }
  if (e.key === 'Escape') closeSearch();
});

document.getElementById('searchInput')?.addEventListener('input', (e) => {
  const query = e.target.value.toLowerCase().trim();
  const results = document.getElementById('searchResults');
  
  if (!query) {
    results.innerHTML = '';
    return;
  }
  
  const matches = searchData.filter(a => 
    a.title.toLowerCase().includes(query) ||
    a.intro.toLowerCase().includes(query) ||
    a.channel.toLowerCase().includes(query) ||
    a.tags.some(t => t.toLowerCase().includes(query))
  ).slice(0, 8);
  
  if (matches.length === 0) {
    results.innerHTML = '<div class="search-empty">No articles found</div>';
    return;
  }
  
  results.innerHTML = matches.map(a => {
    const highlight = (text) => text.replace(new RegExp('(' + query + ')', 'gi'), '<span class="search-highlight">$1</span>');
    return `<a href="/posts/${a.id}/${a.slug}/" class="search-result">
      <div class="search-result-title">${highlight(a.title)}</div>
      <div class="search-result-meta">
        <span class="tag">${a.channel.replace(/-/g, ' ')}</span>
        <span class="difficulty ${a.difficulty}">${a.difficulty}</span>
      </div>
      <div class="search-result-excerpt">${highlight(a.intro)}...</div>
    </a>`;
  }).join('');
});
</script>
</body></html>