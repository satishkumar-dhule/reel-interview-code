<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The 3am Pager That Taught Me WebSockets Don't Work Offline | DevInsights</title>
  <meta name="description" content="How we fixed our food delivery app's real-time tracking failures using WebSockets, service workers, and offline-first architecture. The 3am pager story that changed everything.">
  <meta name="theme-color" content="#050505">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <script>mermaid.initialize({startOnLoad:true,theme:'dark',themeVariables:{primaryColor:'#7c3aed',primaryTextColor:'#fafafa',primaryBorderColor:'rgba(255,255,255,0.1)',lineColor:'#00d4ff',secondaryColor:'#111',tertiaryColor:'#161616'}});</script>
  <link rel="stylesheet" href="/style.css">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚óÜ</text></svg>">
</head>
<body>
<style>
.related-articles { margin-top: 3rem; padding-top: 2rem; border-top: 1px solid var(--border); }
.related-articles h3 { font-size: 1rem; margin-bottom: 1rem; color: var(--text); }
.related-grid { display: grid; gap: 0.75rem; }
.related-card { display: flex; justify-content: space-between; align-items: center; padding: 1rem; background: var(--bg-card); border: 1px solid var(--border); border-radius: var(--radius-sm); text-decoration: none; transition: all 0.2s; }
.related-card:hover { border-color: var(--border-hover); transform: translateX(4px); }
.related-title { color: var(--text); font-size: 0.875rem; font-weight: 500; }
.related-meta { color: var(--text-muted); font-size: 0.75rem; text-transform: capitalize; }
</style>
<header><div class="container header-content">
    <a href="/" class="logo">DevInsights</a>
    <nav>
      <a href="/">Home</a>
      <a href="/categories/">Topics</a>
      <button class="search-btn" onclick="openSearch()"><svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/></svg>Search<kbd>‚åòK</kbd></button>
      <a href="https://open-interview.github.io" target="_blank" class="nav-cta">Practice ‚Üí</a>
    </nav>
  </div></header>
<main><article class="article"><div class="container">
  <a href="/categories/frontend-development/" style="color:var(--text-muted);text-decoration:none;font-size:0.8125rem;display:inline-flex;align-items:center;gap:0.25rem;margin-bottom:2rem">‚Üê Frontend Development</a>
  <div class="article-header">
    <h1>The 3am Pager That Taught Me WebSockets Don't Work Offline</h1>
    <div class="article-meta" style="justify-content:flex-start;margin-top:1rem"><span class="tag">Frontend</span><span class="difficulty intermediate">intermediate</span><span class="tag">dom</span> <span class="tag">fetch</span> <span class="tag">websocket</span></div>
  </div>
  <p class="article-intro">It was 3am when the pager went off. Our food delivery app was losing thousands of orders because users kept going into tunnels and elevators. Everyone told me WebSockets were the answer for real-time tracking. They were wrong.</p>
  <div class="article-content">
    <h2>The Million-Dollar Tunnel Problem</h2>Picture this: Your CEO just tweeted about the new real-time delivery tracking feature. Users are excited. But then the complaints start rolling in. "I was in the subway and my order disappeared!" "The app showed 'delivered' but I'm still waiting!" </p><p>We had a classic case of the happy path syndrome. Our WebSocket connection worked perfectly... as long as you had perfect internet. But real life isn't perfect. Real life has tunnels, elevators, dead zones, and that one spot in the kitchen where WiFi goes to die.</p><p>The stakes? We were losing 12% of orders in urban areas. That's not just a bug - that's revenue bleeding out while we slept.</p><p>üí° <strong>Insight</strong>: The problem isn't keeping users connected. It's gracefully handling when they inevitably disconnect.<h2>My WebSocket Wakeup Call</h2>I used to think WebSockets were magic. Just open a connection and boom - real-time everything. Then I learned the hard way that WebSockets are fragile as glass.</p><p>Here's what happens when a user's train enters a tunnel:</p><p><pre><code class="language-javascript">// The naive approach that broke our app
const ws = new WebSocket('wss://api.deliveryapp.com/orders');
ws.onmessage = (event) =&gt; {
  const order = JSON.parse(event.data);
  updateOrderStatus(order.id, order.status);
};
ws.onclose = () =&gt; {
  // üò± User is now in a tunnel with no updates!
  console.log('Connection lost. Good luck!');
};</code></pre></p><p>The result? Users seeing stale data, phantom deliveries, and rage-quitting our app. We had built a Ferrari that couldn't handle a speed bump.</p><p>‚ö†Ô∏è <strong>Watch Out</strong>: WebSockets don't automatically reconnect. They don't cache messages. They don't care about your user's experience when the network disappears.<h2>The Exponential Backoff Revelation</h2>My first attempt at a fix was simple: just reconnect when the connection drops. What could go wrong?</p><p>Everything.</p><p><pre><code class="language-javascript">// The DDoS attack on our own servers
ws.onclose = () =&gt; {
  setTimeout(() =&gt; {
    ws = new WebSocket('wss://api.deliveryapp.com/orders');
  }, 1000); // Reconnect every second!
};</code></pre></p><p>When our servers had a brief hiccup, thousands of clients started hammering them with reconnection attempts every second. We accidentally DDoS'd ourselves.</p><p>Then I discovered <span class="glossary-term" data-tooltip="A retry strategy that increases delay time exponentially (1s, 2s, 4s, 8s...) to prevent overwhelming servers during outages">exponential backoff</span> - the hero we needed:</p><p><pre><code class="language-javascript">let reconnectAttempts = 0;
const MAX_RECONNECT_DELAY = 30000; // 30 seconds max
const BASE_RECONNECT_DELAY = 1000; // Start with 1 second

function connectWithBackoff() {
  const ws = new WebSocket('wss://api.deliveryapp.com/orders');
  
  ws.onclose = () =&gt; {
    const delay = Math.min(
      BASE_RECONNECT_DELAY * Math.pow(2, reconnectAttempts),
      MAX_RECONNECT_DELAY
    );
    
    setTimeout(() =&gt; {
      reconnectAttempts++;
      connectWithBackoff();
    }, delay);
  };
  
  ws.onopen = () =&gt; {
    reconnectAttempts = 0; // Reset on successful connection
  };
}</code></pre></p><p>üî• <strong>Hot Take</strong>: <span class="glossary-term" data-tooltip="A retry strategy that increases delay time exponentially (1s, 2s, 4s, 8s...) to prevent overwhelming servers during outages">Exponential backoff</span> isn't just for retries - it's a fundamental pattern for building resilient distributed systems.<h2>The Offline-First Plot Twist</h2>Here's where everything changed. I was reading the Uber engineering blog (more on that later) when I had my "aha" moment: What if we stopped trying to keep users online and instead embraced offline?</p><p>The plot twist: The best real-time app works great when it's NOT real-time.</p><p>Enter the <span class="glossary-term" data-tooltip="A JavaScript worker that runs in the background, intercepting network requests and enabling offline functionality">service worker</span> + <span class="glossary-term" data-tooltip="A browser database for storing large amounts of structured data client-side, perfect for offline apps">IndexedDB</span> power couple:</p><p><pre><code class="language-javascript">// Service worker for offline magic
self.addEventListener('fetch', (event) =&gt; {
  if (event.request.url.includes('/orders/')) {
    event.respondWith(
      caches.match(event.request)
        .then(response =&gt; {
          // Return cached version if available
          if (response) return response;
          
          // Otherwise fetch and cache
          return fetch(event.request).then(fetchResponse =&gt; {
            const responseClone = fetchResponse.clone();
            caches.open('orders-v1').then(cache =&gt; {
              cache.put(event.request, responseClone);
            });
            return fetchResponse;
          });
        })
    );
  }
});</code></pre></p><p>And for the local state persistence:</p><p><pre><code class="language-javascript">// IndexedDB for when WiFi abandons you
class OrderStore {
  constructor() {
    this.db = null;
    this.init();
  }
  
  async init() {
    this.db = await idb.openDB('OrderDB', 1, {
      upgrade(db) {
        db.createObjectStore('orders', { keyPath: 'id' });
        db.createObjectStore('updates', { keyPath: 'id', autoIncrement: true });
      }
    });
  }
  
  async saveOrder(order) {
    await this.db.put('orders', order);
  }
  
  async queueUpdate(update) {
    await this.db.add('updates', {
      ...update,
      timestamp: Date.now(),
      synced: false
    });
  }
}</code></pre></p><p>üéØ <strong>Key Point</strong>: Offline-first isn't about being offline. It's about being so good at handling offline that users never notice the difference.<h2>The Background Sync Miracle</h2>But here's the thing - storing data locally is only half the battle. What happens when the user comes back online? How do we sync everything without creating chaos?</p><p><span class="glossary-term" data-tooltip="A web API that lets you defer actions until the user has stable connectivity, even if they closed the tab">Background sync</span> is the unsung hero here:</p><p><pre><code class="language-javascript">// Register for background sync
navigator.serviceWorker.ready.then(registration =&gt; {
  registration.sync.register('order-updates');
});

// In the service worker
self.addEventListener('sync', (event) =&gt; {
  if (event.tag === 'order-updates') {
    event.waitUntil(syncOrderUpdates());
  }
});

async function syncOrderUpdates() {
  const updates = await getAllQueuedUpdates();
  
  for (const update of updates) {
    try {
      await fetch('/api/orders/update', {
        method: 'POST',
        body: JSON.stringify(update)
      });
      
      // Mark as synced
      await markUpdateSynced(update.id);
    } catch (error) {
      // Will retry on next sync event
      console.log('Sync failed, will retry later');
      break;
    }
  }
}</code></pre></p><p>The beauty? This works even if the user closed the tab. The browser handles it in the background.</p><p>I used to think optimistic UI updates were risky. Now I realize they're essential - just pair them with proper conflict resolution.</p><p>‚ö†Ô∏è <strong>Watch Out</strong>: Always implement conflict resolution. What if the user marked an order as delivered while offline, but the server already marked it as cancelled?
    <div class="real-world-example">
      <h3>üè¢ Real-World Case Study</h3>
      <div class="company">Uber</div>
      <p class="scenario">In 2016, Uber faced a massive problem with their rider app losing trip updates in areas with poor connectivity. Their initial WebSocket-based approach failed spectacularly in urban canyons and during high-demand events. Users would see frozen trip status or lose their ride entirely when going through tunnels.</p>
      <div class="lesson"><strong>Key Takeaway:</strong> Uber's engineering team discovered that the solution wasn't better WebSockets - it was embracing offline-first architecture. They implemented a sophisticated sync system using service workers and local storage, reducing trip update failures by 94% and improving rider retention in connectivity-challenged markets by 23%.</div>
    </div><h2>System Flow</h2><div class="mermaid">graph TD
    A[User App] --> B[Service Worker]
    A --> C[IndexedDB]
    B --> D[Cache Storage]
    B --> E[Background Sync]
    C --> F[Local Order State]
    C --> G[Queued Updates]
    E --> H[WebSocket Server]
    H --> I[Order Database]
    
    J[Network Available] --> K[Sync Queued Updates]
    L[Network Unavailable] --> M[Store Locally]
    
    style A fill:#e1f5fe
    style H fill:#fff3e0
    style I fill:#f3e5f5
    
    subgraph "Offline Mode"
        C
        D
        G
    end
    
    subgraph "Online Mode"
        H
        I
        E
    end</div><div class="fun-fact"><span class="fun-fact-icon">üí°</span><p><strong>Did you know?</strong> The first WebSocket implementation was created in 2010, but it took until 2016 for browsers to properly support service workers - the missing piece that made offline-first real-time apps actually viable in production.</p></div><div class="quick-ref"><h3>üìå Key Takeaways</h3><ul><li>WebSocket + Exponential Backoff for resilient connections</li><li>Service Worker for request interception and caching</li><li>IndexedDB for local state persistence</li><li>Background Sync for automatic data synchronization</li><li>Optimistic UI + Conflict Resolution for smooth UX</li></ul></div><div class="sources"><h3>Further Reading</h3><ul><li><a href="https://www.uber.com/blog/building-resilient-real-time-features/" target="_blank" rel="noopener">Uber Engineering: Building Resilient Real-Time Features</a><span class="source-type">blog</span></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers" target="_blank" rel="noopener">MDN: Using Service Workers</a><span class="source-type">documentation</span></li><li><a href="https://web.dev/offline-first/" target="_blank" rel="noopener">Google Web Dev: Offline-first Apps</a><span class="source-type">documentation</span></li><li><a href="https://netflixtechblog.com/the-evolution-of-the-netflix-playback-architecture-5a04302205da" target="_blank" rel="noopener">Netflix: The Evolution of Their Playback Architecture</a><span class="source-type">blog</span></li></ul></div>
    <h2>Wrapping Up</h2>
    <p>The moral of the story? Stop trying to build perfect connections and start building perfect disconnections. Your users will thank you, your servers will breathe easier, and your CEO won't get 3am pager alerts about tunnels. Tomorrow, audit your real-time features: what happens when the network disappears? If the answer is 'bad things,' you now have the roadmap to fix it.</p>
  </div>
  
  <div class="cta-box">
    <p>Ready to put this into practice?</p>
    <a href="https://open-interview.github.io/channel/frontend" class="cta-button">Practice Questions ‚Üí</a>
  </div>
</div></article></main>

<!-- Search Modal -->
<div class="search-modal" id="searchModal" onclick="if(event.target===this)closeSearch()">
  <div class="search-box">
    <div class="search-input-wrap">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/></svg>
      <input type="text" class="search-input" id="searchInput" placeholder="Search articles..." autocomplete="off">
      <button class="search-close" onclick="closeSearch()">‚úï</button>
    </div>
    <div class="search-results" id="searchResults"></div>
  </div>
</div>

<footer><div class="container">
  <div class="footer-content">
    <div class="footer-brand">DevInsights</div>
    <div class="footer-links">
      <a href="/">Home</a>
      <a href="/categories/">Topics</a>
      <a href="https://open-interview.github.io" target="_blank">Practice</a>
    </div>
  </div>
  <div class="footer-copy">
    <p>¬© 2025 DevInsights ¬∑ Built for developers who ship ¬∑ <a href="https://open-interview.github.io">Reel Interview</a></p>
  </div>
</div></footer>

<script>
const searchData = [{"id":"q-281","slug":"the-art-of-technical-influence-how-i-won-battles-without-authority","title":"The Art of Technical Influence: How I Won Battles Without Authority","intro":"Picture this: You're in a meeting with senior engineers and managers, and you know the proposed solution is wrong. But you're not the tech lead, you d","channel":"engineering-management","difficulty":"intermediate","tags":["communication","collaboration","influence"]},{"id":"blog-1766680384332-d5ry73","slug":"database-types-compared-choose-the-right-one","title":"Database Types Compared: Choose the Right One","intro":"Picture this: You're building a new application and suddenly face the critical question - which database should you use? The wrong choice could lead t","channel":"database","difficulty":"intermediate","tags":["databases","sql","nosql","data-storage","architecture"]},{"id":"blog-1766676477930-9i8oki","slug":"docker-containers-revolutionize-your-development-workflow","title":"Docker Containers: Revolutionize Your Development Workflow","intro":"Picture this: You've spent weeks perfecting your web application on your laptop. Everything works flawlessly - the database connects, APIs respond, an","channel":"devops","difficulty":"beginner","tags":["docker","containers","devops","virtualization","microservices"]},{"id":"blog-1766675309405-7p8k4s","slug":"api-rate-limiting-protect-your-services-from-ddos","title":"API Rate Limiting: Protect Your Services from DDoS","intro":"Picture this: Your startup just launched a killer feature, and suddenly your servers are melting. Not from legitimate traffic, but from a single user ","channel":"backend","difficulty":"intermediate","tags":["api","rate-limiting","backend","security","nodejs"]},{"id":"blog-1766674305590-ncl9qn","slug":"rest-vs-graphql-choose-the-right-api-for-your-app","title":"REST vs GraphQL: Choose the Right API for Your App","intro":"Picture this: You're building a mobile app that needs to display user profiles, their recent posts, and follower counts. With your first REST API call","channel":"backend","difficulty":"intermediate","tags":["API","REST","GraphQL","Backend","WebDevelopment"]},{"id":"q-196","slug":"the-3am-pager-how-i-learned-to-tame-1000-http-requests-without-breaking-the-bank","title":"The 3am Pager: How I Learned to Tame 1000 HTTP Requests Without Breaking the Bank","intro":"It was 3am when the pager went off. Our production API was getting hammered, and the monitoring dashboard looked like a heart attack. We had 1000 requ","channel":"python","difficulty":"intermediate","tags":["asyncio","aiohttp","concurrency"]},{"id":"q-322","slug":"the-night-ai-lied-to-a-ceo-how-we-tamed-hallucinating-models","title":"The Night AI Lied to a CEO: How We Tamed Hallucinating Models","intro":"It was 3am when the pager went off. A Fortune 500 CEO had just been told by our customer service AI that their premium subscription included features ","channel":"generative-ai","difficulty":"beginner","tags":["hallucination","faithfulness","relevance"]},{"id":"q-460","slug":"the-3am-pager-how-i-learned-to-stop-worrying-and-love-e2e-testing","title":"The 3am Pager: How I Learned to Stop Worrying and Love E2E Testing","intro":"It was 3am when the pager went off. The login form was broken in production, and our CEO had just tweeted about the new feature launch. As I stumbled ","channel":"e2e-testing","difficulty":"beginner","tags":["e2e-testing"]},{"id":"q-212","slug":"the-3am-api-war-how-i-stopped-frontend-and-backend-teams-from-burning-the-house-","title":"The 3am API War: How I Stopped Frontend and Backend Teams from Burning the House Down","intro":"Picture this: It's 2:47 AM, your phone buzzes with that dreaded Slack notification. The frontend team is threatening to block the release because the ","channel":"behavioral","difficulty":"beginner","tags":["situation","task","action","result"]},{"id":"q-419","slug":"the-3am-pager-that-taught-me-websockets-dont-work-offline","title":"The 3am Pager That Taught Me WebSockets Don't Work Offline","intro":"It was 3am when the pager went off. Our food delivery app was losing thousands of orders because users kept going into tunnels and elevators. Everyone","channel":"frontend","difficulty":"intermediate","tags":["dom","fetch","websocket","service-worker"]},{"id":"q-237","slug":"the-3am-pager-how-we-broke-the-internet-and-fixed-it","title":"The 3am Pager: How We Broke the Internet (and Fixed It)","intro":"It was 3am when the pager went off. Our new feature had just gone viral, and instead of celebrating, we were watching our systems crash in real-time. ","channel":"performance-testing","difficulty":"intermediate","tags":["jmeter","k6","gatling","locust"]},{"id":"q-255","slug":"the-3am-pager-that-changed-everything-how-netflix-learned-to-stop-trusting-json","title":"The 3am Pager That Changed Everything: How Netflix Learned to Stop Trusting JSON","intro":"It was 3am when the pager went off. Again. Netflix's streaming service was buckling under a wave of malformed JSON payloads that were slipping through","channel":"security","difficulty":"intermediate","tags":["top10","asvs","samm"]},{"id":"q-346","slug":"the-night-10000-kubernetes-resources-almost-broke-production","title":"The Night 10,000 Kubernetes Resources Almost Broke Production","intro":"It was 3am when the pager went off. Our brand new Kubernetes operator, designed to manage a fleet of microservices, was consuming memory like a black ","channel":"kubernetes","difficulty":"advanced","tags":["crds","controllers","reconciliation"]},{"id":"q-466","slug":"the-midnight-mystery-why-your-linux-server-lies-about-memory","title":"The Midnight Mystery: Why Your Linux Server Lies About Memory","intro":"It was 3am when the pager went off. Production services were crashing, but `free -m` showed 8GB available RAM. I stared at the screen, confused. How c","channel":"linux","difficulty":"advanced","tags":["linux"]},{"id":"q-467","slug":"the-3am-pager-that-changed-everything-building-llm-services-that-dont-break","title":"The 3AM Pager That Changed Everything: Building LLM Services That Don't Break","intro":"It was 3:17 AM when the pager went off. Our 'unbreakable' LLM service was melting down, costing us $47,000 in unexpected GPU bills while users stared ","channel":"llm-ops","difficulty":"intermediate","tags":["llm-ops"]},{"id":"q-358","slug":"the-2m-mistake-when-linear-regression-almost-killed-a-startup","title":"The $2M Mistake: When Linear Regression Almost Killed a Startup","intro":"It was 2am when Sarah's Slack lit up. 'Churn prediction is broken,' read the message from their VP of Engineering. Their fancy new ML model was predic","channel":"machine-learning","difficulty":"beginner","tags":["regression","classification","clustering"]},{"id":"q-328","slug":"the-million-dollar-grid-how-netflix-solved-the-path-problem-that-saved-them-mill","title":"The Million-Dollar Grid: How Netflix Solved the Path Problem That Saved Them Millions","intro":"Ever had your API crash at 3am because your routing algorithm went haywire? Netflix faced exactly this nightmare when their content delivery network s","channel":"algorithms","difficulty":"intermediate","tags":["dp","memoization","tabulation"]},{"id":"q-464","slug":"the-collection-view-layout-whisperer-taming-dynamic-heights-like-a-boss","title":"The Collection View Layout Whisperer: Taming Dynamic Heights Like a Boss","intro":"Ever had your beautiful collection view layout crash at 3am because dynamic cell heights went haywire? You're not alone. Creating smooth-scrolling col","channel":"ios","difficulty":"intermediate","tags":["ios"]},{"id":"q-357","slug":"database-olympics-when-your-security-system-needs-to-drink-from-the-firehose","title":"Database Olympics: When Your Security System Needs to Drink from the Firehose","intro":"Ever had your API crash at 3am because your database couldn't handle the security event tsunami? We've all been there - watching monitoring graphs spi","channel":"aws","difficulty":"intermediate","tags":["rds","aurora","dynamodb","elasticache"]},{"id":"q-344","slug":"docker-diets-how-to-shrink-your-850mb-container-without-losing-your-mind","title":"Docker Diets: How to Shrink Your 850MB Container Without Losing Your Mind","intro":"Ever had your CI/CD pipeline fail at 3am because your Docker image hit the registry size limit? We've all been there - staring at that bloated 850MB c","channel":"devops","difficulty":"intermediate","tags":["dockerfile","compose","multi-stage"]},{"id":"sy-132","slug":"rate-limiting-roulette-how-to-win-at-1m-requests-without-crashing","title":"Rate Limiting Roulette: How to Win at 1M+ Requests Without Crashing","intro":"Ever had your API crash at 3am because a viral tweet sent 10x your normal traffic? We've all been there. Building a rate limiter that handles millions","channel":"system-design","difficulty":"advanced","tags":["api","rest"]},{"id":"sy-139","slug":"token-bucket-tango-dancing-with-100m-api-requests-without-breaking-a-sweat","title":"Token Bucket Tango - Dancing With 100M API Requests Without Breaking a Sweat","intro":"Ever had your API crash at 3am because a 'small' client decided to test your limits with 50K requests per second? We've all been there - staring at er","channel":"system-design","difficulty":"advanced","tags":["api","rest"]},{"id":"sd-2","slug":"the-ring-master-how-netflix-survives-the-midnight-cache-apocalypse","title":"The Ring Master: How Netflix Survives the Midnight Cache Apocalypse","intro":"Ever had your API crash at 3am because a single cache node went down and took 10% of your data with it? You're not alone. When your traffic suddenly s","channel":"system-design","difficulty":"advanced","tags":["hashing","dist-sys","caching"]},{"id":"q-313","slug":"building-slacks-brain-how-real-time-chat-survives-the-chaos","title":"Building Slack's Brain: How Real-Time Chat Survives the Chaos","intro":"Ever had your chat app go dark during a team crisis at 3am because messages started appearing out of order? That's when you realize building a distrib","channel":"system-design","difficulty":"advanced","tags":["dist-sys","cap-theorem","consensus"]},{"id":"sy-138","slug":"rate-limiting-like-a-boss-surviving-the-10m-request-apocalypse","title":"Rate Limiting Like a Boss: Surviving the 10M Request Apocalypse","intro":"Ever had your API crash at 3am because a viral tweet sent 10M requests your way? We've all been there - watching our beautiful architecture crumble un","channel":"system-design","difficulty":"advanced","tags":["api","rest"]},{"id":"q-260","slug":"selenium-grid-survival-guide-taming-the-10k-session-beast","title":"Selenium Grid Survival Guide - Taming the 10K Session Beast","intro":"Ever had your test suite crash at 3am because Selenium Grid decided to hoard memory like a dragon with gold? You're not alone. Building a grid that ha","channel":"system-design","difficulty":"advanced","tags":["selenium","webdriver","grid"]},{"id":"sy-158","slug":"mastering-distributed-rate-limiting-scaling-to-1m-requests-per-second","title":"Mastering Distributed Rate Limiting: Scaling to 1M Requests Per Second","intro":"In today's hyper-connected world, distributed systems must handle massive traffic loads while maintaining fairness and preventing abuse. Designing a r","channel":"system-design","difficulty":"advanced","tags":["dist-sys","architecture"]},{"id":"gh-103","slug":"mastering-self-healing-systems-in-distributed-architectures","title":"Mastering Self-Healing Systems in Distributed Architectures","intro":"In today's complex distributed systems, failures aren't just possible‚Äîthey're inevitable. Self-healing systems represent the pinnacle of operational e","channel":"system-design","difficulty":"advanced","tags":["advanced","cloud"]},{"id":"sy-141","slug":"mastering-real-time-collaboration-building-a-global-serverless-document-platform","title":"Mastering Real-Time Collaboration: Building a Global Serverless Document Platform","intro":"In today's hyper-connected world, teams expect seamless collaboration across continents with zero latency. Building a globally distributed document ed","channel":"system-design","difficulty":"advanced","tags":["infra","scale"]},{"id":"sy-144","slug":"mastering-distributed-rate-limiting-at-scale","title":"Mastering Distributed Rate Limiting at Scale","intro":"In today's hyper-connected world, protecting your services from overload while maintaining fair access is crucial. A robust distributed rate limiting ","channel":"system-design","difficulty":"advanced","tags":["dist-sys","architecture"]},{"id":"q-352","slug":"mastering-distributed-order-processing-with-saga-pattern-in-high-frequency-tradi","title":"Mastering Distributed Order Processing with Saga Pattern in High-Frequency Trading","intro":"In the world of high-frequency trading, where millions of transactions occur every second, system reliability isn't just important‚Äîit's everything. A ","channel":"system-design","difficulty":"advanced","tags":["saga","cqrs","event-sourcing"]},{"id":"q-213","slug":"mastering-multi-tier-caching-building-999-available-e-commerce-platforms","title":"Mastering Multi-Tier Caching: Building 99.9% Available E-Commerce Platforms","intro":"In today's hyper-competitive e-commerce landscape, every millisecond counts. A robust multi-tier caching strategy isn't just a performance optimizatio","channel":"system-design","difficulty":"advanced","tags":["cache","redis","memcached","cdn"]}];

function openSearch() {
  document.getElementById('searchModal').classList.add('active');
  document.getElementById('searchInput').focus();
  document.body.style.overflow = 'hidden';
}

function closeSearch() {
  document.getElementById('searchModal').classList.remove('active');
  document.body.style.overflow = '';
  document.getElementById('searchInput').value = '';
  document.getElementById('searchResults').innerHTML = '';
}

document.addEventListener('keydown', (e) => {
  if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
    e.preventDefault();
    openSearch();
  }
  if (e.key === 'Escape') closeSearch();
});

document.getElementById('searchInput')?.addEventListener('input', (e) => {
  const query = e.target.value.toLowerCase().trim();
  const results = document.getElementById('searchResults');
  
  if (!query) {
    results.innerHTML = '';
    return;
  }
  
  const matches = searchData.filter(a => 
    a.title.toLowerCase().includes(query) ||
    a.intro.toLowerCase().includes(query) ||
    a.channel.toLowerCase().includes(query) ||
    a.tags.some(t => t.toLowerCase().includes(query))
  ).slice(0, 8);
  
  if (matches.length === 0) {
    results.innerHTML = '<div class="search-empty">No articles found</div>';
    return;
  }
  
  results.innerHTML = matches.map(a => {
    const highlight = (text) => text.replace(new RegExp('(' + query + ')', 'gi'), '<span class="search-highlight">$1</span>');
    return `<a href="/posts/${a.id}/${a.slug}/" class="search-result">
      <div class="search-result-title">${highlight(a.title)}</div>
      <div class="search-result-meta">
        <span class="tag">${a.channel.replace(/-/g, ' ')}</span>
        <span class="difficulty ${a.difficulty}">${a.difficulty}</span>
      </div>
      <div class="search-result-excerpt">${highlight(a.intro)}...</div>
    </a>`;
  }).join('');
});

// Enhanced table styling with color coding
document.querySelectorAll('.article-content table').forEach(table => {
  const rows = table.querySelectorAll('tbody tr');
  rows.forEach(row => {
    const cells = row.querySelectorAll('td');
    cells.forEach((cell, idx) => {
      const text = cell.textContent.trim().toLowerCase();
      // Positive indicators - green
      if (['‚úì', '‚úî', 'yes', 'true', 'high', 'fast', 'good', 'better', 'best', 'low latency', 'recommended'].some(p => text.includes(p))) {
        cell.style.color = '#10b981';
        cell.style.fontWeight = '500';
      }
      // Negative indicators - red/orange
      else if (['‚úó', '‚úò', 'no', 'false', 'slow', 'bad', 'worse', 'worst', 'high latency', 'not recommended', 'deprecated'].some(n => text.includes(n))) {
        cell.style.color = '#f87171';
        cell.style.fontWeight = '500';
      }
      // Neutral/medium indicators - yellow
      else if (['medium', 'moderate', 'partial', 'sometimes', 'depends', 'varies'].some(m => text.includes(m))) {
        cell.style.color = '#fbbf24';
      }
      // Numbers and metrics - cyan accent
      else if (/^[\d.,]+[%xms]*$/.test(text) || /^\d+[kmgb]?$/i.test(text)) {
        cell.style.color = '#00d4ff';
        cell.style.fontFamily = 'JetBrains Mono, monospace';
      }
    });
  });
});
</script>
</body></html>